{"/home/travis/build/npmtest/node-npmtest-bpmn/test.js":"/* istanbul instrument in package npmtest_bpmn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bpmn/lib.npmtest_bpmn.js":"/* istanbul instrument in package npmtest_bpmn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bpmn = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bpmn = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bpmn/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bpmn && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bpmn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bpmn\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bpmn.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_bpmn.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bpmn.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_bpmn.__dirname + '/lib.npmtest_bpmn.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/public.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar async = require('async');\r\n\r\nvar definitions = require('./parsing/definitions.js');\r\nvar handlers = require('./handler.js');\r\nvar bpmnProcesses = require('./process.js');\r\nvar logger = require('./logger.js');\r\n\r\n\r\nvar ProcessManager = require('./manager').ProcessManager;\r\n\r\nmodule.exports = exports = new ProcessManager();\r\n\r\nexports.ProcessManager = ProcessManager;\r\n\r\nexports.clearCache = function() {\r\n    definitions.clearCache();\r\n};\r\n\r\nexports.logLevels = logger.logLevels;\r\n\r\n/**\r\n * A BPMN process is created.\r\n *\r\n * @param {String} bpmnFilePath Full qualified file name of the bpmn file to be loaded\r\n * @param {Function} callback\r\n * @return {BPMNProcessClient}\r\n */\r\nexports.createUnmanagedProcess = function(bpmnFilePath, callback) {\r\n    var processDefinition, error;\r\n    var processDefinitions = definitions.getBPMNProcessDefinitions(bpmnFilePath);\r\n    var handler = handlers.getHandlerFromFile(bpmnFilePath);\r\n\r\n    if (processDefinitions.length === 1) {\r\n        processDefinition = processDefinitions[0];\r\n    } else {\r\n        error = new Error(\"The BPMN file '\" + bpmnFilePath + \"'. contains more than one process definition. Use 'createCollaboratingProcesses' instead of 'createProcess'\");\r\n        if(!callback) {\r\n            throw error;\r\n        } else {\r\n            callback(error);\r\n        }\r\n    }\r\n\r\n    bpmnProcesses.createBPMNProcess(null, processDefinition, handler, function(err, bpmnProcess){\r\n        if(!callback){\r\n            return;\r\n        }\r\n\r\n        callback(err, bpmnProcess.processClient);\r\n    });\r\n\r\n};\r\n\r\n/**\r\n * A BPMN process is created.\r\n *\r\n * @param {String} bpmnXML\r\n * @param {String|object} handler\r\n * @param {Function} callback\r\n * @return {BPMNProcessClient}\r\n */\r\nexports.createUnmanagedProcessFromXML = function(bpmnXML, handler, callback) {\r\n    var processDefinition, error;\r\n    var processDefinitions = definitions.getBPMNDefinitionsFromXML(bpmnXML, \"Standalone\");\r\n\r\n    if (processDefinitions.length === 1) {\r\n        processDefinition = processDefinitions[0];\r\n    } else {\r\n        error = new Error(\"The BPMN XML contains more than one process definition. Use 'createCollaboratingProcesses' instead of 'createProcess'\");\r\n        return callback(error);\r\n    }\r\n\r\n    if(typeof handler === 'string') {\r\n        handler = handlers.getHandlerFromString(handler);\r\n    }\r\n\r\n    bpmnProcesses.createBPMNProcess(null, processDefinition, handler, function(err, bpmnProcess){\r\n        callback(err, bpmnProcess.processClient);\r\n    });\r\n\r\n};\r\n\r\n/**\r\n * An array of BPMN processes are created.\r\n *\r\n * @param {String} bpmnFilePath Full qualified file name of the bpmn file to be loaded\r\n * @param {Function} callback\r\n */\r\nexports.createUnmanagedCollaboratingProcesses = function(bpmnFilePath, callback) {\r\n    var processes = {};\r\n    var processDefinitions = definitions.getBPMNProcessDefinitions(bpmnFilePath);\r\n    var handler = handlers.getHandlerFromFile(bpmnFilePath);\r\n\r\n    async.eachSeries(processDefinitions, function(processDefinition, done) {\r\n        bpmnProcesses.createBPMNProcess(null, processDefinition, handler, function(err, bpmnProcess){\r\n            if(err){\r\n                done(err);\r\n            }\r\n            processes[processDefinition.name] = bpmnProcess;\r\n            done();\r\n        });\r\n    }, function(err){\r\n        var clients = [];\r\n\r\n        Object.keys(processes).forEach(function(name){\r\n            var bpmnProcess = processes[name];\r\n\r\n            var participants = bpmnProcess.getProcessDefinition().getCollaboratingParticipants();\r\n\r\n            participants.forEach(function (participant) {\r\n                bpmnProcess.addParticipant(participant.name, processes[participant.name]);\r\n            });\r\n\r\n            clients.push(bpmnProcess.processClient);\r\n        });\r\n\r\n        callback(err, clients);\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * An array of BPMN processes are created.\r\n *\r\n * @param {String} bpmnXML\r\n * @param {String|object} handler\r\n * @param {Function} callback\r\n */\r\nexports.createUnmanagedCollaboratingProcessesFromXML = function(bpmnXML, handler, callback) {\r\n    var processes = {};\r\n    var processDefinitions = definitions.getBPMNDefinitionsFromXML(bpmnXML);\r\n\r\n    if(typeof handler === 'string'){\r\n        handler = handlers.getHandlerFromString(handler);\r\n    }\r\n\r\n    async.eachSeries(processDefinitions, function(processDefinition, done) {\r\n        bpmnProcesses.createBPMNProcess(null, processDefinition, handler, function(err, bpmnProcess){\r\n            if(err){\r\n                done(err);\r\n            }\r\n            processes[processDefinition.name] = bpmnProcess;\r\n            done();\r\n        });\r\n    }, function(err){\r\n        var clients = [];\r\n\r\n        Object.keys(processes).forEach(function(name){\r\n            var bpmnProcess = processes[name];\r\n\r\n            var participants = bpmnProcess.getProcessDefinition().getCollaboratingParticipants();\r\n\r\n            participants.forEach(function (participant) {\r\n                bpmnProcess.addParticipant(participant.name, processes[participant.name]);\r\n            });\r\n\r\n            clients.push(bpmnProcess.processClient);\r\n        });\r\n\r\n        callback(err, clients);\r\n    });\r\n};\r\n\r\n/**\r\n * Maps bpmn names to valid handler names.\r\n * @param {String} bpmnName\r\n * @type {String}\r\n */\r\nexports.mapName2HandlerName = function(bpmnName) {\r\n    return handlers.mapName2HandlerName(bpmnName);\r\n};\r\n\r\n/**\r\n * Loads, parses, and validates BPMN definitions from bpmnFilePath\r\n * If validation error occur, an exception of type BPMNParseErrorQueue is thrown.\r\n * @param {String} bpmnFilePath\r\n * @param {Boolean=} cache If true, the definitions are cached.\r\n * @return {Array.<BPMNProcessDefinition|BPMNCollaborationDefinition>}\r\n */\r\nexports.getBPMNDefinitions = function(bpmnFilePath, cache) {\r\n    var bpmnDefinitions = null;\r\n    if (cache) {\r\n        bpmnDefinitions = definitions.getCachedBPMNDefinitions(bpmnFilePath);\r\n    } else {\r\n        bpmnDefinitions = definitions.getBPMNDefinitions(bpmnFilePath);\r\n    }\r\n    return bpmnDefinitions;\r\n};\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/definitions.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar fileUtils = require('../utils/file.js');\r\nvar utils = require('../utils/utils.js');\r\nvar parser = require(\"./parser.js\");\r\nvar errors = require(\"./errors.js\");\r\n\r\nvar bpmnDefinitionsCache = {};\r\nexports.clearCache = function() {\r\n    bpmnDefinitionsCache = {};\r\n};\r\n\r\n/**\r\n * @param bpmnFilePath\r\n * @return {BPMNProcessDefinition}\r\n */\r\nexports.getBPMNProcessDefinition = function(bpmnFilePath) {\r\n    var processDefinition;\r\n    var processDefinitions = getBPMNProcessDefinitions(bpmnFilePath);\r\n\r\n    if (processDefinitions.length === 1) {\r\n        processDefinition = processDefinitions[0];\r\n    } else {\r\n        throw new Error(\"The BPMN file '\" + bpmnFilePath + \"'. contains more than one process definition. Use 'getBPMNProcessDefinitions' instead of 'getBPMNProcessDefinition'\");\r\n    }\r\n    return processDefinition;\r\n};\r\n\r\n/**\r\n * @param bpmnFilePath\r\n * @return {Array.<BPMNProcessDefinition>}\r\n */\r\nvar getBPMNProcessDefinitions = exports.getBPMNProcessDefinitions = function(bpmnFilePath) {\r\n    var bpmnDefinitions = getCachedBPMNDefinitions(bpmnFilePath);\r\n    return getProcessDefinitions(bpmnDefinitions);\r\n};\r\n\r\n/**\r\n * @param bpmnFilePath\r\n * @return {Array.<BPMNCollaborationDefinition>}\r\n */\r\nexports.getBPMNCollaborationDefinitions = function(bpmnFilePath) {\r\n    var bpmnDefinitions = getCachedBPMNDefinitions(bpmnFilePath);\r\n    return getCollaborationDefinitions(bpmnDefinitions);\r\n};\r\n\r\nfunction getCollaborationDefinitions(bpmnDefinitions) {\r\n    return bpmnDefinitions.filter(function(definition) {\r\n        return definition.isCollaborationDefinition;\r\n    });\r\n}\r\n\r\nfunction getProcessDefinitions(bpmnDefinitions) {\r\n    return bpmnDefinitions.filter(function(definition) {\r\n        return definition.isProcessDefinition;\r\n    });\r\n}\r\n\r\n/**\r\n * We don't read bpmn files asynchronously (like node is loading js-files also synchronously),\r\n * thus we have to cache the definitions.\r\n * @param {String} bpmnFilePath\r\n * @return {Array.<BPMNProcessDefinition|BPMNCollaborationDefinition>}\r\n */\r\nfunction getCachedBPMNDefinitions(bpmnFilePath) {\r\n    var bpmnDefinitions = bpmnDefinitionsCache[bpmnFilePath];\r\n\r\n    if (!bpmnDefinitions) {\r\n        bpmnDefinitions = getBPMNDefinitions(bpmnFilePath);\r\n        bpmnDefinitionsCache[bpmnFilePath] = bpmnDefinitions;\r\n    }\r\n\r\n    return bpmnDefinitions;\r\n}\r\nexports.getCachedBPMNDefinitions = getCachedBPMNDefinitions;\r\n\r\n/**\r\n *\r\n * @param bpmnDefinitions\r\n */\r\nfunction setCollaborationDefinitions(bpmnDefinitions){\r\n    var collaborationDefinitions = getCollaborationDefinitions(bpmnDefinitions);\r\n    var processDefinitions = getProcessDefinitions(bpmnDefinitions);\r\n    var errorQueue = errors.createBPMNParseErrorQueue();\r\n    processDefinitions.forEach(function(processDefinition) {\r\n        processDefinition.validate(errorQueue);\r\n        errorQueue.check();\r\n        processDefinition.attachCollaborationDefinitions(collaborationDefinitions);\r\n    });\r\n}\r\n\r\n/**\r\n * @param {String} bpmnFilePath\r\n * @return {Array.<BPMNProcessDefinition|BPMNCollaborationDefinition>}\r\n */\r\nfunction getBPMNDefinitions(bpmnFilePath) {\r\n    var errorQueue = errors.createBPMNParseErrorQueue();\r\n    var bpmnDefinitions, bpmnXML;\r\n\r\n    try {\r\n        bpmnXML = fs.readFileSync(bpmnFilePath, \"utf8\");\r\n        bpmnDefinitions = parser.parse(bpmnXML, errorQueue, utils.toUpperCamelCase(fileUtils.removeFileExtension(path.basename(bpmnFilePath))), bpmnFilePath);\r\n    } catch (e) {\r\n        errorQueue.addError(\"DF1\", null, \"Could not parse the BPMN file '\" + bpmnFilePath + \"'. Error: '\" + e + \"'\");\r\n    }\r\n\r\n    errorQueue.check();\r\n\r\n    setCollaborationDefinitions(bpmnDefinitions);\r\n\r\n    return bpmnDefinitions;\r\n}\r\nexports.getBPMNDefinitions = getBPMNDefinitions;\r\n\r\n\r\n/**\r\n * @param {String} bpmnXML\r\n * @param {String=} mainProcessName\r\n * @param {String=} bpmnFilePath\r\n * @return {Array.<BPMNProcessDefinition|BPMNCollaborationDefinition>}\r\n */\r\nfunction getBPMNDefinitionsFromXML(bpmnXML, mainProcessName, bpmnFilePath) {\r\n    var errorQueue = errors.createBPMNParseErrorQueue();\r\n    var bpmnDefinitions;\r\n\r\n    try {\r\n        bpmnDefinitions = parser.parse(bpmnXML, errorQueue, mainProcessName, bpmnFilePath);\r\n    } catch (e) {\r\n        errorQueue.addError(\"DF1\", null, \"Could not parse the BPMN XML string'. Error: '\" + e + \"'\");\r\n    }\r\n\r\n    errorQueue.check();\r\n\r\n    setCollaborationDefinitions(bpmnDefinitions);\r\n\r\n    return bpmnDefinitions;\r\n}\r\nexports.getBPMNDefinitionsFromXML = getBPMNDefinitionsFromXML;\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/utils/file.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar fs = require('fs');\r\nvar nfs = require('node-fs/lib/fs.js');\r\nvar paths = require('path');\r\n\r\nvar encoding = \"utf8\";\r\n\r\n/**\r\n * Create directories recursively if they don't exist\r\n * @param {String} path\r\n */\r\nexports.writeDirSync = function(path){\r\n   nfs.mkdirSync(path, \"0777\", true);\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @param {String} data\r\n */\r\nexports.writeFileSync = function(name, data){\r\n    fs.writeFileSync(name, data, encoding);\r\n};\r\n\r\n/**\r\n *\r\n * @param {String} fileName\r\n * @return {String}\r\n */\r\nexports.getFileExtension = function(fileName) {\r\n    var extension = null;\r\n    var index = fileName.lastIndexOf(\".\");\r\n    if (index > -1) {\r\n        extension = fileName.substring(index + 1);\r\n    }\r\n    return extension;\r\n};\r\n\r\n/**\r\n *\r\n * @param {string} fileName\r\n * @return {string}\r\n */\r\nexports.removeFileExtension = function(fileName) {\r\n    var name = fileName;\r\n    var index = name.lastIndexOf(\".\");\r\n    if (index > -1) {\r\n        name = name.substring(0, index);\r\n    }\r\n    return name;\r\n};\r\n\r\n/**\r\n *\r\n * @param {string} currentPath\r\n * @param {function(currentPath:string, fileName:string, currentFile:string)} handleFile\r\n */\r\nvar traverseFileSystem = exports.traverseFileSystem = function (currentPath, handleFile) {\r\n    var fileNames;\r\n    if (fs.existsSync(currentPath)) {\r\n        fileNames = fs.readdirSync(currentPath);\r\n        fileNames.forEach(function(fileName) {\r\n            var currentFile = currentPath + '/' + fileName;\r\n            var stats = fs.statSync(currentFile);\r\n            if (stats.isFile()) {\r\n                handleFile(currentPath, fileName, currentFile);\r\n            }\r\n            else if (stats.isDirectory()) {\r\n                traverseFileSystem(currentFile, handleFile);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n/**\r\n * @param {string} path\r\n * @param {string} name\r\n */\r\nvar concatFSNames = exports.concatFSNames = function(path, name) {\r\n    //return (path.substr(0, 1) === '/' ? path + name : path + '/' + name);\r\n    return paths.join(path, name);\r\n};\r\n\r\nexports.readJSONObject = function(fileName) {\r\n    var fileContents = fs.readFileSync(fileName, encoding);\r\n    return JSON.parse(fileContents);\r\n};\r\n\r\n/**\r\n * Returns lines separated by \\n as string array. Mainly used for testing.\r\n * @param fileName\r\n * @return {Array.<String>}\r\n */\r\nexports.readLines = function(fileName) {\r\n    var fileContents = fs.readFileSync(fileName, encoding);\r\n    return fileContents.split(/\\r?\\n/);\r\n};\r\n\r\n/**\r\n * @param {string} path\r\n */\r\nexports.removeDirectorySync = function(path) {\r\n    fs.rmdirSync(path);\r\n};\r\n\r\n/**\r\n * @param {String} path\r\n * @param {String} fileName\r\n */\r\nvar removeFileSync = exports.removeFileSync = function(path, fileName) {\r\n    var filePath = concatFSNames(path, fileName);\r\n    if (fs.existsSync(filePath)) {\r\n        fs.unlinkSync(filePath);\r\n    }\r\n};\r\n\r\n/**\r\n * @param {string} path\r\n */\r\nexports.cleanDirectorySync = function(path) {\r\n    traverseFileSystem(path, removeFileSync);\r\n};\r\n\r\n/**\r\n * @param {String} dirtyPath\r\n * @return {String}\r\n */\r\nexports.cleanPath = function(dirtyPath) {\r\n    return dirtyPath.replace(/[:!`~\\^@*#¢¬ç?¦\\|&;\\$%@\"<>\\(\\){}\\[\\]\\+, \\t\\n]/g, \"\");\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/utils/utils.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * @param {String} name\r\n * @return {String}\r\n */\r\nexports.toUpperCamelCase = function(name) {\r\n    var result = \"\";\r\n    var parts = name.split(/\\s+/g);\r\n    parts.forEach(function(part) {\r\n        result += firstToUpper(part);\r\n    });\r\n    return result;\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @return {String}\r\n */\r\nvar firstToUpper = exports.firstToUpper = function(name) {\r\n    return (name.substring(0,1).toUpperCase() + name.substring(1));\r\n};\r\n\r\nvar HashMap = exports.HashMap = function HashMap(caseSensitive) {\r\n    this.values = {};\r\n    this.caseSensitive = caseSensitive !== undefined ? caseSensitive : true;\r\n    this.prefix = '.'; // a char not allowed in JS names\r\n    this.offset = this.prefix.length;\r\n};\r\n\r\n/**\r\n * @param {{toString: function}} key\r\n * @returns {string}\r\n * @private\r\n */\r\nHashMap.prototype._getKeyValue = function(key) {\r\n    // no built in JS attribute contains '.'\r\n    var k = this.prefix + key;\r\n    return (this.caseSensitive ? k : k.toLowerCase());\r\n};\r\n\r\n/**\r\n * @param {{toString: function}} key\r\n * @param {*} value\r\n */\r\nHashMap.prototype.set = function(key, value) {\r\n  var prefixedKey = this._getKeyValue(key);\r\n  this.values[prefixedKey] = value;\r\n};\r\n\r\n/**\r\n * @param {{toString: function}} key\r\n * @return {*}\r\n */\r\nHashMap.prototype.get = function(key) {\r\n    var prefixedKey = this._getKeyValue(key);\r\n    return (this.values[prefixedKey]);\r\n};\r\n\r\nHashMap.prototype.clear = function() {\r\n    this.values = {};\r\n};\r\n\r\n/**\r\n * @returns {Array.<String>}\r\n */\r\nHashMap.prototype.getKeys = function() {\r\n    var self = this;\r\n    var prefixedKeys = Object.keys(this.values);\r\n    return prefixedKeys.map(function(prefixedKey) {\r\n        return prefixedKey.substring(self.offset);\r\n    });\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/parser.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar sax = require('sax');\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar fileUtils = require('../utils/file.js');\r\nvar utils = require('../utils/utils.js');\r\nvar debug = require('../debugger.js');\r\nvar processDefinition = require('./processDefinition.js');\r\nvar tasks = require('./tasks.js');\r\nvar startEvents = require('./startEvents.js');\r\nvar boundaryEvents = require('./boundaryEvents.js');\r\nvar endEvents = require('./endEvents.js');\r\nvar sequenceFlows = require('./sequenceFlows.js');\r\nvar gateways = require('./gateways.js');\r\nvar callActivity = require('./callActivity.js');\r\nvar events = require('./events.js');\r\nvar intermediateEvents = require('./intermediateEvents.js');\r\nvar subProcess = require('./subProcess.js');\r\nvar messageFlows = require(\"./messageFlows.js\");\r\nvar participant = require(\"./participant.js\");\r\nvar collaborationDefinition = require(\"./collaborationDefinition.js\");\r\nvar parserUtils = require(\"./parserUtils\");\r\n\r\nvar BPMN2NAMESPACE = \"http://www.omg.org/spec/BPMN/20100524/MODEL\";\r\n\r\n/**\r\n * @param {Object} prefix2NamespaceMap Maps prefixes to namespaces. ASSUMPTION: prefixes map uniquely to namespaces\r\n * @param node\r\n */\r\nfunction addNamespaces(prefix2NamespaceMap, node) {\r\n    var attributes = node.attributes;\r\n    if (attributes) {\r\n        var keys = Object.keys(attributes);\r\n        keys.forEach(function(key) {\r\n            var attribute = attributes[key];\r\n            if (attribute.prefix === \"xmlns\") {\r\n                // NOTE: we assume that namespace prefixes are unique - which is not necessarily true\r\n                prefix2NamespaceMap[attribute.local] = attribute.value;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @param {Object} importNamespace2LocationMap Maps import namespaces to locations.\r\n * @param importNode\r\n */\r\nfunction addImport(importNamespace2LocationMap, importNode) {\r\n    var location = parserUtils.getAttributesValue(importNode, \"location\");\r\n    var namespace = parserUtils.getAttributesValue(importNode, \"namespace\");\r\n    importNamespace2LocationMap[namespace] = location;\r\n}\r\n\r\n\r\n/**\r\n * @param {String} bpmnXML\r\n * @param {BPMNParseErrorQueue=} errorQueue\r\n * @param {String=} mainProcessName\r\n * @param {String=} fileName\r\n * @return {Array.<BPMNProcessDefinition>}\r\n */\r\nexports.parse = function(bpmnXML, errorQueue, mainProcessName, fileName) {\r\n\r\n    var parser = sax.parser(true, {\"xmlns\": true});\r\n    var topLevelDefinitions = [];\r\n    var processStack = [];\r\n    /** @type {BPMNProcessDefinition} */\r\n    var subProcessDefinition = null;\r\n    /** @type {BPMNProcessDefinition} */\r\n    var currentProcessDefinition = null;\r\n    /** @type {BPMNFlowObject|BPMNSequenceFlow} */\r\n    var currentProcessElement = null;\r\n    /** @type {BPMNCollaborationDefinition} */\r\n    var currentCollaborationDefinition = null;\r\n    /** @type {BPMNMessageFlow|BPMNParticipant} */\r\n    var currentCollaborationElement = null;\r\n    var prefix2NamespaceMap = {};\r\n    var importNamespace2LocationMap = {};\r\n    var debuggerInterface = null;\r\n\r\n    if (errorQueue && fileName) {\r\n        errorQueue.fileName = fileName;\r\n    }\r\n\r\n    parser.onerror = function (e) {\r\n        errorQueue.addError(\"NOPARSE\", {}, e.message);\r\n        parser.resume();\r\n    };\r\n\r\n    parser.onopentag = function (node) {\r\n        var localName = node.local;\r\n        var inBPMN2Namespace = node.uri === BPMN2NAMESPACE;\r\n\r\n        addNamespaces(prefix2NamespaceMap, node);\r\n\r\n        if (!debuggerInterface && debug.isDebuggerElement(node) && fileName) {\r\n            debuggerInterface = debug.createDebuggerInterface(node, fileName);\r\n        }\r\n\r\n        if (inBPMN2Namespace) {\r\n\r\n            if (collaborationDefinition.isCollaborationDefinitionName(localName)) {\r\n                currentCollaborationDefinition = collaborationDefinition.createBPMNCollaborationDefinition(node);\r\n                topLevelDefinitions.push(currentCollaborationDefinition);\r\n                currentProcessDefinition = null;\r\n            }\r\n\r\n            if (currentCollaborationDefinition) {\r\n                if (messageFlows.isMessageFlowName(localName)) {\r\n                    currentCollaborationElement = messageFlows.createBPMNMessageFlow(node);\r\n                    currentCollaborationDefinition.addMessageFlow(currentCollaborationElement);\r\n                } else if (participant.isParticipantName(localName)) {\r\n                    currentCollaborationElement = participant.createBPMNParticipant(node);\r\n                    currentCollaborationDefinition.addParticipant(currentCollaborationElement);\r\n                }\r\n            }\r\n\r\n            if (processDefinition.isProcessName(localName)) {\r\n                if (processDefinition.isExecutable(node)) {\r\n                    currentProcessDefinition = processDefinition.createBPMNProcessDefinition(node, debuggerInterface);\r\n                    if (!currentProcessDefinition.name && mainProcessName) {\r\n                        currentProcessDefinition.name = mainProcessName;\r\n                    }\r\n                    topLevelDefinitions.push(currentProcessDefinition);\r\n                    currentCollaborationDefinition = null;\r\n                } else {\r\n                    currentProcessDefinition = null;\r\n                }\r\n            }\r\n\r\n            if (localName === \"import\") {\r\n                addImport(importNamespace2LocationMap, node);\r\n            }\r\n\r\n            if (currentProcessDefinition) {\r\n                if (tasks.isTaskName(localName)) {\r\n                    currentProcessElement = tasks.createBPMNTask(node);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                } else if (sequenceFlows.isSequenceFlowName(localName)) {\r\n                    currentProcessElement = sequenceFlows.createBPMNSequenceFlow(node);\r\n                    currentProcessDefinition.addSequenceFlow(currentProcessElement);\r\n                } else if (startEvents.isStartEventName(localName)) {\r\n                    currentProcessElement = startEvents.createBPMNStartEvent(node);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                } else if (boundaryEvents.isBoundaryEventName(localName)) {\r\n                    currentProcessElement = boundaryEvents.createBPMNBoundaryEvent(node);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                } else if (boundaryEvents.isTimerEventName(localName)) {\r\n                    currentProcessElement.isTimerEvent = true;\r\n                } else if (endEvents.isEndEventName(localName)) {\r\n                    currentProcessElement = endEvents.createBPMNEndEvent(node);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                } else if (gateways.isGatewayName(localName)) {\r\n                    currentProcessElement = gateways.createBPMNGateway(node, errorQueue);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                } else if (callActivity.isCallActivityName(localName)) {\r\n                    currentProcessElement = callActivity.createBPMNCallActivity(node, fileName, prefix2NamespaceMap, importNamespace2LocationMap);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                } else if (intermediateEvents.isIntermediateThrowEventName(localName)) {\r\n                    currentProcessElement = intermediateEvents.createBPMNIntermediateThrowEvent(node);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                } else if (intermediateEvents.isIntermediateCatchEventName(localName)) {\r\n                    currentProcessElement = intermediateEvents.createBPMNIntermediateCatchEvent(node);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                } else if (events.isMessageEventName(localName)) {\r\n                    currentProcessElement.isMessageEvent = true;\r\n                } else if (subProcess.isSubProcessName(localName)) {\r\n                    subProcessDefinition = processDefinition.createBPMNProcessDefinition(node, errorQueue);\r\n                    currentProcessElement = subProcess.createBPMNSubProcess(node, subProcessDefinition);\r\n                    currentProcessDefinition.addFlowObject(currentProcessElement);\r\n                    processStack.push(currentProcessDefinition);\r\n                    currentProcessDefinition = subProcessDefinition;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    parser.onclosetag = function (node) {\r\n        if (subProcess.isSubProcessName(node)) {\r\n            if (processStack.length > 0) {\r\n                currentProcessDefinition = processStack.pop();\r\n            }\r\n        }\r\n    };\r\n\r\n    parser.write(bpmnXML).close();\r\n\r\n    return topLevelDefinitions;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/debugger.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar restify = require('restify');\r\nvar urls = require('url');\r\nvar parserUtils = require(\"./parsing/parserUtils.js\");\r\n\r\n/**\r\n * @param node\r\n * @param {String} fileName\r\n * @constructor\r\n */\r\nexports.createDebuggerInterface = function(node, fileName) {\r\n    return (new DebuggerInterface(parserUtils.getAttributesValue(node, \"href\"), fileName));\r\n};\r\n\r\n/**\r\n * @param node\r\n * @return {Boolean}\r\n */\r\nexports.isDebuggerElement = function(node) {\r\n    return (node.uri === 'http://e2e.ch/bpmneditor/debugger' && node.local === 'position');\r\n};\r\n\r\n/**\r\n * @param {String} url\r\n * @param {String} fileName\r\n * @constructor\r\n */\r\nvar DebuggerInterface = exports.DebuggerInterface = function(url, fileName) {\r\n    this.fileName = fileName;\r\n    this.url = urls.parse(url);\r\n};\r\n\r\n/**\r\n * @returns {boolean}\r\n */\r\nDebuggerInterface.prototype.isInDebugger = function() {\r\n    return (global.v8debug !== undefined);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @param {Logger} logger\r\n * @param {Function} done\r\n */\r\nDebuggerInterface.prototype.sendPosition = function(flowObject, logger, done) {\r\n    var self = this;\r\n    var baseUrl = self.url.protocol + '//' + self.url.host;\r\n    var debuggerMessage = {\r\n        filename: this.fileName,\r\n        position: {}\r\n    };\r\n    var client;\r\n\r\n    if (flowObject.bpmnId) {\r\n        debuggerMessage.position.bpmnId = flowObject.bpmnId;\r\n    }\r\n\r\n    try {\r\n        // if we are here, we are debugging so performance is no issue so\r\n        // we create a new client all the time which is simple and robust\r\n        client = self.createRestClient(baseUrl);\r\n        client.post(self.url.pathname, debuggerMessage, function(error, req, res, obj) {\r\n            if (error) {\r\n                logger.error(\"Error sending position to '\" + self.url.href + \"'. Error: \" + error);\r\n            }\r\n\r\n\t\t\t// client must be closed before calling done() because done might lead to another sendPosition call\r\n            client.close();\r\n\r\n            if (done) {\r\n                logger.debug(\"DebuggerInterface: Sending '\" + JSON.stringify(debuggerMessage) + \"' to '\" + self.url.href + \"'\");\r\n                done(error, req, res, obj);\r\n            }\r\n         });\r\n    } catch (e) {\r\n        logger.error(\"Error sending position to '\" + self.url.href + \"'. Error: \" + e);\r\n        done(e);\r\n    }\r\n};\r\n\r\n/**\r\n * @param {String} url\r\n * @return {*}\r\n */\r\nDebuggerInterface.prototype.createRestClient = function(url) {\r\n    return restify.createJsonClient({url: url});\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/parserUtils.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * @param node\r\n * @param {String} attributeName\r\n * @return {String}\r\n */\r\nexports.getAttributesValue = function(node, attributeName) {\r\n    var value = null, attribute = null;\r\n    var attributes = node.attributes;\r\n\r\n    if (attributes) {\r\n        attribute = attributes[attributeName];\r\n        value = attribute ? attribute.value : null;\r\n    }\r\n    return value;\r\n};\r\n\r\n/**\r\n * @param {String} prefixedName A name such as ns1:blah\r\n * @return {{prefix: String, localName: String}}\r\n */\r\nexports.splitPrefixedName = function(prefixedName) {\r\n    var result = {prefix: \"\", localName: \"\"};\r\n    var colon = prefixedName.indexOf(\":\");\r\n\r\n    if (colon) {\r\n        result.prefix = prefixedName.substring(0, colon);\r\n        result.localName = prefixedName.substring(colon + 1);\r\n    } else {\r\n        result.localName = prefixedName;\r\n    }\r\n\r\n    return result;\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/processDefinition.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar parserUtils = require(\"./parserUtils\");\r\n\r\n/**\r\n * @param node\r\n * @param {DebuggerInterface=} debuggerInterface\r\n * @return {BPMNProcessDefinition}\r\n */\r\nexports.createBPMNProcessDefinition = function(node, debuggerInterface) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n\r\n    return (new BPMNProcessDefinition(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        debuggerInterface\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isProcessName = function(localName) {\r\n    return (localName === 'process');\r\n};\r\n\r\n/**\r\n * @param node\r\n * @return {Boolean}\r\n */\r\nexports.isExecutable = function(node) {\r\n    var isExecutable = parserUtils.getAttributesValue(node, \"isExecutable\");\r\n    return (!isExecutable || isExecutable === 'true');\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {DebuggerInterface=} debuggerInterface\r\n * @constructor\r\n */\r\nvar BPMNProcessDefinition = exports.BPMNProcessDefinition = function(bpmnId, name, debuggerInterface) {\r\n    this.bpmnId = bpmnId;\r\n    this.name = name;\r\n    this.flowObjects = [];\r\n    this.sequenceFlows = [];\r\n    this.messageFlows = [];\r\n\r\n    // Process Elements = Flow objects + connection objects + artifacts\r\n    // Semantics of these names is described in http://de.wikipedia.org/wiki/Business_Process_Model_and_Notation#Notation\r\n    this.processElementIndex = null;\r\n    this.sequenceFlowBySourceIndex = null;\r\n    this.sequenceFlowByTargetIndex = null;\r\n    this.messageFlowBySourceIndex = null;\r\n    this.messageFlowByTargetIndex = null;\r\n    this.boundaryEventsByAttachmentIndex = null;\r\n    this.nameMap = null;\r\n    this.isProcessDefinition = true;\r\n    /** {Array.<BPMNParticipant>} */\r\n    this.collaboratingParticipants = [];\r\n\r\n    if (debuggerInterface) {\r\n        this.debuggerInterface = debuggerInterface;\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNProcessDefinition.prototype.validate = function(errorQueue) {\r\n    var self = this;\r\n    var processElements = this.getProcessElements();\r\n\r\n    processElements.forEach(function(processElement) {\r\n        if (processElement.validate && typeof processElement.validate === 'function') {\r\n            processElement.validate(self, errorQueue);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @return {*}\r\n */\r\nBPMNProcessDefinition.prototype.getProcessElement = function(bpmnId) {\r\n    if (!(this.processElementIndex)) {\r\n        this.processElementIndex = this._buildIndex();\r\n    }\r\n    return this.processElementIndex[bpmnId];\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @return {BPMNFlowObject}\r\n */\r\nBPMNProcessDefinition.prototype.getFlowObject = function(bpmnId) {\r\n    return this.getProcessElement(bpmnId);\r\n};\r\n\r\n/**\r\n * @param {{sourceRef: String}} flow\r\n * @return {BPMNFlowObject}\r\n */\r\nBPMNProcessDefinition.prototype.getSourceFlowObject = function(flow) {\r\n    return this.getProcessElement(flow.sourceRef);\r\n};\r\n\r\n/**\r\n * @return {Array.<BPMNStartEvent>}\r\n */\r\nBPMNProcessDefinition.prototype.getStartEvents = function() {\r\n    return this.flowObjects.filter(function(flowObject) {\r\n        return (flowObject.isStartEvent);\r\n    });\r\n};\r\n\r\n/**\r\n * @return {Array.<BPMNActivity>}\r\n */\r\nBPMNProcessDefinition.prototype.getBoundaryEvents = function() {\r\n    return this.flowObjects.filter(function(flowObject) {\r\n        return (flowObject.isBoundaryEvent);\r\n    });\r\n};\r\n\r\n/**\r\n * @param {BPMNActivity} activity\r\n * @return {Array.<BPMNActivity>}\r\n */\r\nBPMNProcessDefinition.prototype.getBoundaryEventsAt = function(activity) {\r\n    if (!this.boundaryEventsByAttachmentIndex) {\r\n        this.boundaryEventsByAttachmentIndex = this.buildBoundaryEventsByAttachmentIndex();\r\n    }\r\n    return (this.boundaryEventsByAttachmentIndex[activity.bpmnId] || []);\r\n};\r\n\r\n/**\r\n */\r\nBPMNProcessDefinition.prototype.buildBoundaryEventsByAttachmentIndex = function() {\r\n    var index = {};\r\n    var self = this;\r\n    var boundaryEvents = this.getBoundaryEvents();\r\n\r\n    boundaryEvents.forEach(function(boundaryEvent) {\r\n        var attachedToRef = boundaryEvent.attachedToRef;\r\n        var activity = self.getFlowObject(attachedToRef);\r\n\r\n        if (activity) {\r\n            if (activity.isWaitTask) {\r\n                var entry = index[attachedToRef];\r\n                if (entry) {\r\n                    entry.push(boundaryEvent);\r\n                } else {\r\n                    index[attachedToRef] = [boundaryEvent];\r\n                }\r\n            } else {\r\n                throw new Error(\"The activity '\" + activity.name + \"' has a boundary event but this is allowed only for wait tasks such as user or receive tasks.\");\r\n            }\r\n        } else {\r\n             throw new Error(\"Cannot find the activity the boundary event '\" + boundaryEvent.name +\r\n                \"' is attached to (activity BPMN ID: '\" + boundaryEvent.attachedToRef + \"'.\");\r\n        }\r\n    });\r\n\r\n    return index;\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @return {BPMNFlowObject}\r\n */\r\nBPMNProcessDefinition.prototype.getFlowObjectByName = function(name) {\r\n    var bpmnId = this.getIdByName(name);\r\n    return this.getFlowObject(bpmnId);\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @return {String}\r\n */\r\nBPMNProcessDefinition.prototype.getIdByName = function(name) {\r\n    if (!(this.nameMap)) {\r\n        this.nameMap = buildNameMap(this.getFlowObjects());\r\n    }\r\n    return this.nameMap[name];\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Array.<BPMNFlowObject>}\r\n */\r\nBPMNProcessDefinition.prototype.getNextFlowObjects = function(flowObject) {\r\n    var nextFlowObjects = [];\r\n    var self = this;\r\n    var outgoingSequenceFlows = this.getOutgoingSequenceFlows(flowObject);\r\n\r\n    outgoingSequenceFlows.forEach(function(flow){\r\n        nextFlowObjects.push(self.getProcessElement(flow.targetRef));\r\n    });\r\n    return nextFlowObjects;\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Array.<BPMNSequenceFlow>}\r\n */\r\nBPMNProcessDefinition.prototype.getIncomingSequenceFlows = function(flowObject) {\r\n    return this._getFlows(\"sequenceFlowByTargetIndex\", \"sequenceFlows\", flowObject, false);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Boolean}\r\n */\r\nBPMNProcessDefinition.prototype.hasIncomingSequenceFlows = function(flowObject) {\r\n    var outgoingFlows = this.getIncomingSequenceFlows(flowObject);\r\n    return (outgoingFlows.length > 0);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Array.<BPMNSequenceFlow>}\r\n */\r\nBPMNProcessDefinition.prototype.getOutgoingSequenceFlows = function(flowObject) {\r\n    return this._getFlows(\"sequenceFlowBySourceIndex\", \"sequenceFlows\", flowObject, true);\r\n};\r\n\r\n/**\r\n * @param {BPMNSequenceFlow} sequenceFlow\r\n */\r\nBPMNProcessDefinition.prototype.addSequenceFlow = function(sequenceFlow) {\r\n    this.sequenceFlowBySourceIndex = null;\r\n    this.sequenceFlowByTargetIndex = null;\r\n    this.sequenceFlows.push(sequenceFlow);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Boolean}\r\n */\r\nBPMNProcessDefinition.prototype.hasOutgoingSequenceFlows = function(flowObject) {\r\n    var outgoingFlows = this.getOutgoingSequenceFlows(flowObject);\r\n    return (outgoingFlows.length > 0);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n */\r\nBPMNProcessDefinition.prototype.addFlowObject = function(flowObject) {\r\n    this.processElementIndex = null;\r\n    this.nameMap = null;\r\n    this.boundaryEventsByAttachmentIndex = null;\r\n    this.flowObjects.push(flowObject);\r\n};\r\n\r\n/**\r\n * @return {Array.<BPMNFlowObject>}\r\n */\r\nBPMNProcessDefinition.prototype.getFlowObjects = function() {\r\n    return this.flowObjects;\r\n};\r\n\r\n/**\r\n * @return {Array.<Object>}\r\n */\r\nBPMNProcessDefinition.prototype.getProcessElements = function() {\r\n    var flowObjects = this.getFlowObjects();\r\n    return (flowObjects.concat(this.sequenceFlows));\r\n};\r\n\r\n/**\r\n * Attach the collaborations participants and message flows to the process definitions for easier access\r\n * @param {Array.<BPMNCollaborationDefinition>} collaborationDefinitions\r\n */\r\nBPMNProcessDefinition.prototype.attachCollaborationDefinitions = function(collaborationDefinitions) {\r\n    var self = this;\r\n\r\n    collaborationDefinitions.forEach(function(collaborationDefinition) {\r\n        var processParticipant = collaborationDefinition.getParticipantByProcessId(self.bpmnId);\r\n\r\n        if (processParticipant) {\r\n            self.name = processParticipant.name;\r\n            var collaboratingParticipants = collaborationDefinition.getCollaboratingParticipants(self.bpmnId);\r\n            self.addCollaboratingParticipants(collaboratingParticipants);\r\n            var messageFlows = collaborationDefinition.getMessageFlows();\r\n            self.addMessageFlows(messageFlows);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param {String} participantName\r\n * @return {BPMNParticipant}\r\n */\r\nBPMNProcessDefinition.prototype.getParticipantByName = function(participantName) {\r\n    var participants = this.collaboratingParticipants.filter(function(participant) {\r\n        return (participant.name === participantName);\r\n    });\r\n\r\n    if (participants.length > 1) {\r\n        throw new Error(\"There is more than one collaboration participant having the same name: '\" + participantName + \"'\");\r\n    }\r\n\r\n    return participants[0];\r\n};\r\n\r\n/**\r\n * @param {String} processDefinitionId\r\n * @return {BPMNParticipant}\r\n */\r\nBPMNProcessDefinition.prototype.getParticipantById = function(processDefinitionId) {\r\n    var participants = this.collaboratingParticipants.filter(function(participant) {\r\n        return (participant.processRef === processDefinitionId);\r\n    });\r\n    return participants[0];\r\n};\r\n\r\n/**\r\n * @return {Array.<BPMNParticipant>}\r\n */\r\nBPMNProcessDefinition.prototype.getCollaboratingParticipants = function() {\r\n    return this.collaboratingParticipants;\r\n};\r\n\r\n/**\r\n * @param {Array.<BPMNParticipant>} participants\r\n */\r\nBPMNProcessDefinition.prototype.addCollaboratingParticipants = function(participants) {\r\n    var self = this;\r\n    participants.forEach(function(participant) {\r\n        if (!self.getParticipantByName(participant.name)) {\r\n            self.collaboratingParticipants.push(participant);\r\n        }\r\n    });\r\n };\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Array.<BPMNMessageFlow>}\r\n */\r\nBPMNProcessDefinition.prototype.getIncomingMessageFlows = function(flowObject) {\r\n    return this._getFlows(\"messageFlowByTargetIndex\", \"messageFlows\", flowObject, false);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Array.<BPMNMessageFlow>}\r\n */\r\nBPMNProcessDefinition.prototype.getOutgoingMessageFlows = function(flowObject) {\r\n    return this._getFlows(\"messageFlowBySourceIndex\", \"messageFlows\", flowObject, true);\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @return {Array.<BPMNMessageFlow>}\r\n */\r\nBPMNProcessDefinition.prototype.getMessageFlowsBySourceName = function(flowObjectName) {\r\n    var flowObject = this.getFlowObjectByName(flowObjectName);\r\n    return this.getOutgoingMessageFlows(flowObject);\r\n};\r\n\r\n/**\r\n * @param {Array.<BPMNMessageFlow>} messageFlows\r\n */\r\nBPMNProcessDefinition.prototype.addMessageFlows = function(messageFlows) {\r\n    var self = this;\r\n\r\n    messageFlows.forEach(function(messageFlow) {\r\n        if (self.getProcessElement(messageFlow.targetRef)) {\r\n            messageFlow.targetProcessDefinitionId = self.bpmnId;\r\n            self.messageFlows.push(messageFlow);\r\n        } else if (self.getProcessElement(messageFlow.sourceRef)) {\r\n            messageFlow.sourceProcessDefinitionId = self.bpmnId;\r\n            self.messageFlows.push(messageFlow);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @return {Object}\r\n * @private\r\n */\r\nBPMNProcessDefinition.prototype._buildIndex = function() {\r\n    var index = {};\r\n    var processElements = this.getProcessElements();\r\n\r\n    processElements.forEach(function(processElement) {\r\n        index[processElement.bpmnId] = processElement;\r\n    });\r\n    return index;\r\n};\r\n\r\n/**\r\n * @param {String} indexName\r\n * @param {String} flowContainerName\r\n * @param {BPMNFlowObject} flowObject\r\n * @param {Boolean} isOutgoingFlow\r\n * @returns {*|Array}\r\n * @private\r\n */\r\nBPMNProcessDefinition.prototype._getFlows = function(indexName, flowContainerName, flowObject, isOutgoingFlow) {\r\n    if (!this[indexName]) {\r\n        this[indexName] = buildFlowIndex(this[flowContainerName], isOutgoingFlow);\r\n    }\r\n    return (this[indexName][flowObject.bpmnId] || []);\r\n};\r\n\r\n/**\r\n * @param {Boolean} indexBySource If false or undefined, we index by target.\r\n * @param {Array} flows\r\n * @return {Object}\r\n */\r\nfunction buildFlowIndex(flows, indexBySource) {\r\n    var index = {};\r\n\r\n    flows.forEach(function(flow) {\r\n        var ref = indexBySource ? flow.sourceRef : flow.targetRef;\r\n        var entry = index[ref];\r\n\r\n        if (entry) {\r\n            entry.push(flow);\r\n        } else {\r\n            index[ref] = [flow];\r\n        }\r\n    });\r\n    return index;\r\n}\r\n\r\n/**\r\n * @param {Array.<{name: string, bpmnId: string}>} objects\r\n * @return {Object}\r\n * @private\r\n */\r\nfunction buildNameMap(objects) {\r\n    var map = {};\r\n\r\n    objects.forEach(function(object) {\r\n        var name = object.name;\r\n\r\n        if (map[name]) {\r\n            throw new Error(\"Process element name '\" + name + \"' must be unique.\");\r\n        } else {\r\n            map[name] = object.bpmnId;\r\n        }\r\n    });\r\n\r\n    return map;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/tasks.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar parserUtils = require(\"./parserUtils\");\r\n\r\nvar BPMNActivity = require(\"./activity.js\").BPMNActivity;\r\n\r\n/**\r\n * @param node\r\n * @constructor\r\n */\r\nexports.createBPMNTask = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n\r\n    return (new BPMNTask(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isTaskName = function(localName) {\r\n    return (localName.toLowerCase().indexOf(\"task\") > -1);\r\n};\r\n\r\n/**\r\n * Subsumes all kind of tasks\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNTask = exports.BPMNTask = function(bpmnId, name, type) {\r\n    BPMNActivity.call(this, bpmnId, name, type);\r\n    this.isWaitTask = type === 'task' || type === 'userTask' || type === 'receiveTask' || type === 'manualTask';\r\n};\r\nutil.inherits(BPMNTask, BPMNActivity);\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNTask.prototype.validate = function(processDefinition, errorQueue) {\r\n    this.assertName(errorQueue);\r\n    this.assertIncomingSequenceFlows(processDefinition, errorQueue);\r\n    this.assertOutgoingSequenceFlows(processDefinition, errorQueue);\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/activity.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar BPMNFlowObject = require(\"./flowObject.js\").BPMNFlowObject;\r\n\r\nexports.activityEndHandlerPostfix = \"Done\";\r\n/**\r\n * Subsumes all kind of tasks\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNActivity = exports.BPMNActivity = function(bpmnId, name, type) {\r\n    BPMNFlowObject.call(this, bpmnId, name, type);\r\n    this.isActivity = true;\r\n};\r\nutil.inherits(BPMNActivity, BPMNFlowObject);\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/flowObject.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * Subsumes all kind process elements that have incoming and outgoing flows.\r\n * Name according to http://de.wikipedia.org/wiki/Business_Process_Model_and_Notation#Notation\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNFlowObject = exports.BPMNFlowObject = function(bpmnId, name, type) {\r\n    this.bpmnId = bpmnId;\r\n    this.name = name;\r\n    this.type = type;\r\n    this.isFlowObject = true;\r\n};\r\n\r\n/**\r\n * Semantics: emit tokens along all outgoing flows. This is the default behavior\r\n * @param {BPMNProcess} currentProcess\r\n * @param {Object} data\r\n */\r\nBPMNFlowObject.prototype.emitTokens = function(currentProcess, data) {\r\n    var self = this;\r\n    currentProcess.onFlowObjectEnd(self.name, data, function() {\r\n        var outgoingSequenceFlows = currentProcess.processDefinition.getOutgoingSequenceFlows(self);\r\n        outgoingSequenceFlows.forEach(function(outgoingSequenceFlow) {\r\n            currentProcess.emitTokenAlong(self, outgoingSequenceFlow, data);\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNFlowObject.prototype.assertName = function(errorQueue) {\r\n    var name = this.name.trim();\r\n    if (name === \"\") {\r\n        errorQueue.addError(\"FO1\", this, \"Found a \" + this.type + \" flow object having no name. BPMN id='\" + this.bpmnId + \"'.\");\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNFlowObject.prototype.assertOutgoingSequenceFlows = function(processDefinition, errorQueue) {\r\n    if (!processDefinition.hasOutgoingSequenceFlows(this)) {\r\n        errorQueue.addError(\"FO2\", this, \"The \" + this.type + \" '\" + this.name + \"' must have at least one outgoing sequence flow.\");\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNFlowObject.prototype.assertOneOutgoingSequenceFlow = function(processDefinition, errorQueue) {\r\n    var outgoingFlows = processDefinition.getOutgoingSequenceFlows(this);\r\n    if (outgoingFlows.length !== 1) {\r\n        errorQueue.addError(\"FO3\", this, \"The \" + this.type + \" '\" + this.name + \"' must have exactly one outgoing sequence flow.\");\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNFlowObject.prototype.assertNoOutgoingSequenceFlows = function(processDefinition, errorQueue) {\r\n    if (processDefinition.hasOutgoingSequenceFlows(this)) {\r\n        errorQueue.addError(\"FO4\", this, \"The \" + this.type + \" '\" + this.name + \"' must not have outgoing sequence flows.\");\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNFlowObject.prototype.assertIncomingSequenceFlows = function(processDefinition, errorQueue) {\r\n    if (!processDefinition.hasIncomingSequenceFlows(this)) {\r\n        errorQueue.addError(\"FO5\", this, \"The \" + this.type + \" '\" + this.name + \"' must have at least one incoming sequence flow.\");\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNFlowObject.prototype.assertNoIncomingSequenceFlows = function(processDefinition, errorQueue) {\r\n    if (processDefinition.hasIncomingSequenceFlows(this)) {\r\n        errorQueue.addError(\"FO5\", this, \"The \" + this.type + \" '\" + this.name + \"' must not have incoming sequence flows.\");\r\n    }\r\n};\r\n\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/startEvents.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar parserUtils = require(\"./parserUtils\");\r\nvar BPMNFlowObject = require(\"./flowObject.js\").BPMNFlowObject;\r\n\r\n/**\r\n * @param node\r\n * @return {BPMNStartEvent}\r\n */\r\nexports.createBPMNStartEvent = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n\r\n    return (new BPMNStartEvent(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isStartEventName = function(localName) {\r\n    return (localName.toLowerCase().indexOf(\"start\") > -1);\r\n};\r\n\r\n/**\r\n * Subsumes all kind of start events\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNStartEvent = exports.BPMNStartEvent = function(bpmnId, name, type) {\r\n    BPMNFlowObject.call(this, bpmnId, name, type);\r\n    this.isStartEvent = true;\r\n};\r\nutil.inherits(BPMNStartEvent, BPMNFlowObject);\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNStartEvent.prototype.validate = function(processDefinition, errorQueue) {\r\n    this.assertName(errorQueue);\r\n    this.assertNoIncomingSequenceFlows(processDefinition, errorQueue);\r\n    this.assertOneOutgoingSequenceFlow(processDefinition, errorQueue);\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/boundaryEvents.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar parserUtils = require(\"./parserUtils\");\r\nvar BPMNFlowObject = require(\"./flowObject.js\").BPMNFlowObject;\r\n\r\n/**\r\n * @param node\r\n * @return {BPMNBoundaryEvent}\r\n */\r\nexports.createBPMNBoundaryEvent = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n    return (new BPMNBoundaryEvent(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local,\r\n        getValue(node, \"attachedToRef\")\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isBoundaryEventName = function(localName) {\r\n    return (localName === \"boundaryEvent\");\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isTimerEventName = function(localName) {\r\n    return (localName === \"timerEventDefinition\");\r\n};\r\n\r\n/**\r\n * Subsumes all kind of start events\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @param {String} attachedToRef\r\n * @constructor\r\n */\r\nvar BPMNBoundaryEvent = exports.BPMNBoundaryEvent = function(bpmnId, name, type, attachedToRef) {\r\n    BPMNFlowObject.call(this, bpmnId, name, type);\r\n    this.isBoundaryEvent = true;\r\n    this.attachedToRef = attachedToRef;\r\n};\r\nutil.inherits(BPMNBoundaryEvent, BPMNFlowObject);\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNBoundaryEvent.prototype.validate = function(processDefinition, errorQueue) {\r\n    this.assertName(errorQueue);\r\n    this.assertNoIncomingSequenceFlows(processDefinition, errorQueue);\r\n    this.assertOneOutgoingSequenceFlow(processDefinition, errorQueue);\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/endEvents.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar parserUtils = require(\"./parserUtils.js\");\r\nvar BPMNFlowObject = require(\"./flowObject.js\").BPMNFlowObject;\r\n\r\n/**\r\n * @param node\r\n * @return {BPMNEndEvent}\r\n */\r\nexports.createBPMNEndEvent = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n    return (new BPMNEndEvent(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isEndEventName = function(localName) {\r\n    return (localName.toLowerCase().indexOf(\"end\") > -1);\r\n};\r\n\r\n/**\r\n * Subsumes all kind of end events\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNEndEvent = exports.BPMNEndEvent = function(bpmnId, name, type) {\r\n    BPMNFlowObject.call(this, bpmnId, name, type);\r\n    this.isEndEvent = true;\r\n};\r\nutil.inherits(BPMNEndEvent, BPMNFlowObject);\r\n\r\n/**\r\n * Semantics: emit token to the parent process - if there is one. Otherwise we are at the end\r\n *          of the main process and thus delete it from the cache.\r\n * @param {BPMNProcess} currentProcess\r\n * @param {Object} data\r\n */\r\nBPMNEndEvent.prototype.emitTokens = function(currentProcess, data) {\r\n    var endEventName = this.name;\r\n    var parentProcess = currentProcess.parentProcess;\r\n\r\n    currentProcess.onFlowObjectEnd(endEventName, data, function() {\r\n        if (parentProcess) {\r\n            var currentCallActivityName = currentProcess.parentToken.position;\r\n            currentProcess.onProcessEnd(endEventName);\r\n            parentProcess.emitActivityEndEvent(currentCallActivityName, data);\r\n        } else {\r\n            currentProcess.onProcessEnd(endEventName, true);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNEndEvent.prototype.validate = function(processDefinition, errorQueue) {\r\n    this.assertName(errorQueue);\r\n    this.assertIncomingSequenceFlows(processDefinition, errorQueue);\r\n    this.assertNoOutgoingSequenceFlows(processDefinition, errorQueue);\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/sequenceFlows.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar parserUtils = require(\"./parserUtils\");\r\n\r\n/**\r\n * @param node\r\n * @constructor\r\n */\r\nexports.createBPMNSequenceFlow = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n\r\n    return (new BPMNSequenceFlow(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local,\r\n        getValue(node, \"sourceRef\"),\r\n        getValue(node, \"targetRef\")\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isSequenceFlowName = function(localName) {\r\n    return (localName.toLowerCase().indexOf(\"sequenceflow\") > -1);\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @param {String} sourceRef\r\n * @param {String} targetRef\r\n * @constructor\r\n */\r\nvar BPMNSequenceFlow = exports.BPMNSequenceFlow = function(bpmnId, name, type, sourceRef, targetRef) {\r\n    this.bpmnId = bpmnId;\r\n    this.name = name;\r\n    this.type = type;\r\n    this.sourceRef = sourceRef;\r\n    this.targetRef = targetRef;\r\n    this.isSequenceFlow = true;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/gateways.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar handler = require('../handler.js');\r\nvar parserUtils = require(\"./parserUtils\");\r\nvar BPMNFlowObject = require(\"./flowObject.js\").BPMNFlowObject;\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isGatewayName = function(localName) {\r\n    return (localName.toLowerCase().indexOf(\"gateway\") > -1);\r\n};\r\n\r\n/**\r\n * @param node\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n * @return {BPMNExclusiveGateway|BPMNParallelGateway}\r\n */\r\nexports.createBPMNGateway = function(node, errorQueue) {\r\n    var getAttributeValue = parserUtils.getAttributesValue;\r\n    var gateway = null;\r\n    var localName = node.local;\r\n    var name = getAttributeValue(node, \"name\");\r\n    var id = getAttributeValue(node, \"id\");\r\n\r\n    if (isExclusiveGatewayName(localName)) {\r\n        gateway = new BPMNExclusiveGateway(id, name, node.local);\r\n    } else if (isParallelGatewayName(localName)) {\r\n        gateway = new BPMNParallelGateway(id, name, node.local);\r\n    } else {\r\n        errorQueue.addError(\"UnsupportedGateway\", {bpmnId: id, name: name, type: node.local}, \"The gateway '\" + name + \"' is not supported yet.\");\r\n    }\r\n    return gateway;\r\n};\r\n\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nvar isExclusiveGatewayName = function(localName) {\r\n    return (localName === \"exclusiveGateway\");\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNExclusiveGateway = exports.BPMNExclusiveGateway = function(bpmnId, name, type) {\r\n    BPMNFlowObject.call(this, bpmnId, name, type);\r\n    this.isExclusiveGateway = true;\r\n};\r\nutil.inherits(BPMNExclusiveGateway, BPMNFlowObject);\r\n\r\n/**\r\n * Semantics: emit token along the first outgoing flow having an event handler that evaluates to true\r\n * @param {BPMNProcess} currentProcess\r\n * @param {Object} data\r\n */\r\nBPMNExclusiveGateway.prototype.emitTokens = function(currentProcess, data) {\r\n    var self = this;\r\n    var emittedToken = false;\r\n    var outgoingSequenceFlows = currentProcess.processDefinition.getOutgoingSequenceFlows(self);\r\n    var isDiverging = outgoingSequenceFlows.length > 1;\r\n    var handlerName;\r\n\r\n    currentProcess.onFlowObjectEnd(self.name, data, function() {\r\n        outgoingSequenceFlows.forEach(function(outgoingSequenceFlow) {\r\n            if (emittedToken) {\r\n                return;\r\n            }\r\n\r\n            if (isDiverging) {\r\n                handlerName = self.name + handler.handlerNameSeparator + outgoingSequenceFlow.name;\r\n                if (handler.callHandler(handlerName, currentProcess, data)) {\r\n                    if(currentProcess.getCurrentTrx()){\r\n                        currentProcess.getCurrentTrx().processChoice(currentProcess.processDefinition.name, currentProcess.getProcessId(), self.name, outgoingSequenceFlow.name);\r\n                        currentProcess.getCurrentTrx().end();\r\n                    }\r\n                    currentProcess.emitTokenAlong(self, outgoingSequenceFlow, data);\r\n                    emittedToken = true;\r\n                }\r\n            } else {\r\n                if(currentProcess.getCurrentTrx()){\r\n                    currentProcess.getCurrentTrx().end();\r\n                }\r\n                currentProcess.emitTokenAlong(self, outgoingSequenceFlow, data);\r\n                emittedToken = true;\r\n            }\r\n        });\r\n    });\r\n };\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNExclusiveGateway.prototype.validate = function(processDefinition, errorQueue) {\r\n    var self = this;\r\n\r\n    this.assertName(errorQueue);\r\n    assertGatewayFlowCardinality(this, processDefinition, errorQueue);\r\n\r\n    var outgoingSequenceFlows = processDefinition.getOutgoingSequenceFlows(this);\r\n    outgoingSequenceFlows.forEach(function(outgoingSequenceFlow) {\r\n        var name = outgoingSequenceFlow.name;\r\n        if (!name || name.trim() === '') {\r\n            errorQueue.addError(\"XG1\", outgoingSequenceFlow,\r\n                \"Outgoing flows of the \" + self.type + \" '\" + self.name + \"' must have names.\");\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nvar isParallelGatewayName = function(localName) {\r\n    return (localName === \"parallelGateway\");\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNParallelGateway = exports.BPMNParallelGateway = function(bpmnId, name, type) {\r\n    BPMNFlowObject.call(this, bpmnId, name, type);\r\n    this.isParallelGateway = true;\r\n};\r\nutil.inherits(BPMNParallelGateway, BPMNFlowObject);\r\n\r\n/**\r\n * Semantics: wait until all tokens arrive and then emit tokens along all outgoing flows\r\n * @param {BPMNProcess} process\r\n * @param {Object} data\r\n */\r\nBPMNParallelGateway.prototype.emitTokens = function(process, data) {\r\n    var self = this;\r\n    var state = process.state;\r\n    var numberOfIncomingFlows = process.processDefinition.getIncomingSequenceFlows(self).length;\r\n    var numberOfTokens;\r\n\r\n    state.createTokenAt(self.name, process.processId);\r\n\r\n    numberOfTokens = state.numberOfTokensAt(self);\r\n    if (numberOfTokens === numberOfIncomingFlows) {\r\n        process.onFlowObjectEnd(self.name, data, function() {\r\n            state.removeAllTokensAt(self);\r\n            var outgoingSequenceFlows = process.processDefinition.getOutgoingSequenceFlows(self);\r\n            outgoingSequenceFlows.forEach(function(outgoingSequenceFlow){\r\n                process.emitTokenAlong(self, outgoingSequenceFlow, data);\r\n            });\r\n       });\r\n    } else {\r\n        process.persist();\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNParallelGateway.prototype.validate = function(processDefinition, errorQueue) {\r\n    assertGatewayFlowCardinality(this, processDefinition, errorQueue);\r\n};\r\n\r\n/**\r\n * @param {BPMNParallelGateway | BPMNExclusiveGateway} gateway\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nfunction assertGatewayFlowCardinality(gateway, processDefinition, errorQueue) {\r\n    var outgoingSequenceFlows, incomingSequenceFlows, isDiverging, isConverging;\r\n\r\n    gateway.assertIncomingSequenceFlows(processDefinition, errorQueue);\r\n    gateway.assertOutgoingSequenceFlows(processDefinition, errorQueue);\r\n\r\n    if (!errorQueue.hasErrors()) {\r\n        outgoingSequenceFlows = processDefinition.getOutgoingSequenceFlows(gateway);\r\n        incomingSequenceFlows = processDefinition.getIncomingSequenceFlows(gateway);\r\n\r\n        isDiverging = outgoingSequenceFlows.length > 1;\r\n        isConverging = incomingSequenceFlows.length > 1;\r\n        if (!isDiverging && !isConverging) {\r\n            errorQueue.addError(\"GW1\", gateway, \"The \" + gateway.type + \" '\" + gateway.name + \"' must have more than one incoming or outgoing flow to work as gateway.\");\r\n        }\r\n    }\r\n}","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/handler.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar fileUtils = require('./utils/file.js');\r\n\r\nexports.handlerNameSeparator = '$';\r\n\r\n/**\r\n * @param {String} name\r\n * @param {BPMNProcess} process\r\n * @param {Object=} data\r\n * @param {Function=} handlerDoneCallback\r\n * @private\r\n */\r\nexports.callHandler = function(name, process, data, handlerDoneCallback) {\r\n    var result, handlerType;\r\n    var done = handlerDoneCallback || function() {};\r\n    var eventType = \"callHandler\";\r\n    var handler = getHandlerFromProcess(name, process);\r\n\r\n    if (handler) {\r\n        handlerType = typeof handler;\r\n        if (handlerType === 'function') {\r\n            try {\r\n                result = handler.call(process.processClient, data, done);\r\n            } catch (error) {\r\n                process.logger.error(\"Error in handler '\" + name + \"': \" + error.toString());\r\n                process.defaultErrorHandler.call(process.processClient, error, done);\r\n            }\r\n        } else if (handlerType === 'object') {\r\n            // hierarchical handler used for mocking up sub process handlers. See test cases for examples\r\n            // To keep going we have to call done()\r\n            done();\r\n        } else {\r\n            process.callDefaultEventHandler(eventType, name, mapName2HandlerName(name),\r\n                                            \"Unknown handler type: '\" + handlerType + \"'\", done);\r\n        }\r\n     } else {\r\n        process.callDefaultEventHandler(eventType, name, mapName2HandlerName(name), \"No handler found\", done);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * @param {String} bpmnFilePath\r\n * @return {String}\r\n */\r\nvar getHandlerFileName = exports.getHandlerFileName = function(bpmnFilePath) {\r\n    return (fileUtils.removeFileExtension(bpmnFilePath) + \".js\");\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @param {BPMNProcess} process\r\n * @return {Function | Object}\r\n */\r\nvar getHandlerFromProcess = exports.getHandlerFromProcess = function(name, process) {\r\n    var handlerName = mapName2HandlerName(name);\r\n    var handler = process.eventHandler[handlerName]; // this works as long as event names are unique\r\n    return handler;\r\n};\r\n\r\n/**\r\n * @param {String} bpmnFilePath\r\n * @return {Object}\r\n */\r\nexports.getHandlerFromFile = function(bpmnFilePath) {\r\n    var handlerFilePath = getHandlerFileName(bpmnFilePath);\r\n    return require(handlerFilePath);\r\n};\r\n\r\n/**\r\n * @param {String} moduleString\r\n * @return {Object}\r\n */\r\nexports.getHandlerFromString = function(moduleString) {\r\n    var Module = require('module').Module;\r\n    var handlerModule = new Module();\r\n    handlerModule._compile(stripBOM(moduleString));\r\n    return handlerModule.exports;\r\n};\r\n\r\nfunction stripBOM(content) {\r\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\r\n    // because the buffer-to-string conversion in `fs.readFileSync()`\r\n    // translates it to FEFF, the UTF-16 BOM.\r\n    if (content.charCodeAt(0) === 0xFEFF) {\r\n        content = content.slice(1);\r\n    }\r\n    return content;\r\n}\r\n\r\n/**\r\n * Replace all non-allowed characters with '_', if the name starts with a number prefix it with '_'\r\n * @param {String} name\r\n * @return {String}\r\n */\r\nvar mapName2HandlerName = exports.mapName2HandlerName = function(name) {\r\n    var cleanName = name.replace(/[:!`~\\^@*#¢¬ç?¦\\|&;%@\"<>\\(\\){}\\[\\]\\+, \\t\\n]/g, \"_\");\r\n\r\n    if (cleanName.match(/^[0-9]/)) {\r\n        cleanName = \"_\" + cleanName;\r\n    }\r\n    return cleanName;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/callActivity.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar BPMNFlowObject = require(\"./flowObject.js\").BPMNFlowObject;\r\nvar BPMNActivity = require(\"./activity.js\").BPMNActivity;\r\nvar util = require('util');\r\nvar parserUtils = require(\"./parserUtils\");\r\nvar path = require('path');\r\nvar handlerModule = require('../handler.js');\r\nvar bpmnDefinitions = require('./definitions.js');\r\n\r\n/**\r\n * @param node\r\n * @param {String} baseFileName Name of the current process definition file\r\n * @param {Object} prefix2NamespaceMap\r\n * @param {Object} importNamespace2LocationMap\r\n */\r\nexports.createBPMNCallActivity = function(node, baseFileName, prefix2NamespaceMap, importNamespace2LocationMap) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n    var calledElement = getValue(node, \"calledElement\");\r\n    var splitName = parserUtils.splitPrefixedName(calledElement);\r\n    var calledElementName = splitName.localName;\r\n    var calledElementNamespace = prefix2NamespaceMap[splitName.prefix];\r\n    var relativeLocation = importNamespace2LocationMap[calledElementNamespace];\r\n    var location = relativeLocation ? path.join(path.dirname(baseFileName), relativeLocation) : \"\";\r\n\r\n    return (new BPMNCallActivity(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local,\r\n        calledElementName,\r\n        calledElementNamespace,\r\n        location\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isCallActivityName = function(localName) {\r\n    return (localName.toLowerCase().indexOf(\"call\") > -1);\r\n};\r\n\r\n/**\r\n * Subsumes all kind of tasks\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @param {String} calledElementName\r\n * @param {String} calledElementNamespace\r\n * @param {String} location\r\n * @constructor\r\n */\r\nvar BPMNCallActivity = exports.BPMNCallActivity = function(bpmnId, name, type, calledElementName,\r\n                                                           calledElementNamespace, location) {\r\n    BPMNActivity.call(this, bpmnId, name, type);\r\n    this.isCallActivity = true;\r\n    this.calledElementName = calledElementName;\r\n    this.calledElementNamespace = calledElementNamespace;\r\n    this.location = location;\r\n};\r\nutil.inherits(BPMNCallActivity, BPMNActivity);\r\n\r\n/**\r\n * Semantics: If we are to enter a called processing (returningFromCalledProcess = false), the called process is created and a token\r\n *            is put onto its start state.\r\n *            If we leave the callActivity we just emit a token.\r\n * @param {BPMNProcess} currentProcess\r\n * @param {Object} data\r\n * @param {Function} createBPMNProcess\r\n * @param {Boolean=} returningFromCalledProcess\r\n */\r\nBPMNCallActivity.prototype.emitTokens = function(currentProcess, data, createBPMNProcess, returningFromCalledProcess) {\r\n    var self = this;\r\n    var callActivityName = self.name;\r\n    var processId = currentProcess.processId;\r\n    var calledProcessId = processId + \"::\" + callActivityName;\r\n    var callActivityToken, startEvents;\r\n\r\n    if (returningFromCalledProcess) {\r\n\r\n        BPMNFlowObject.prototype.emitTokens.call(self, currentProcess, data);\r\n        currentProcess.unregisterCalledProcess(calledProcessId);\r\n\r\n    } else {\r\n\r\n        callActivityToken = currentProcess.state.createTokenAt(callActivityName, processId, calledProcessId);\r\n        self.createCalledProcess(callActivityToken, currentProcess, createBPMNProcess, function(err, calledProcess){\r\n            startEvents = calledProcess.processDefinition.getStartEvents();\r\n            if (startEvents.length === 1) {\r\n                calledProcess.triggerEvent(startEvents[0].name);\r\n            } else {\r\n                throw new Error(\"The called process '\" + calledProcess.processDefinition.name +\r\n                    \"' must have exactly one start event.\");\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n/**\r\n * @param {Token} callActivityToken\r\n * @param {BPMNProcess} currentProcess\r\n * @param {Function} createBPMNProcess\r\n * @param {BPMNProcessDefinition=} calledProcessDefinition\r\n * @param {Function} callback\r\n * @return {BPMNProcess}\r\n */\r\nBPMNCallActivity.prototype.createCalledProcess = function(callActivityToken, currentProcess,\r\n                                                          createBPMNProcess, calledProcessDefinition, callback) {\r\n\r\n    if(typeof calledProcessDefinition === 'function'){\r\n        callback = calledProcessDefinition;\r\n        calledProcessDefinition = null;\r\n    }\r\n\r\n    var handler = this.getHandler(currentProcess);\r\n    var processDefinition = calledProcessDefinition || bpmnDefinitions.getBPMNProcessDefinition(this.location);\r\n    var callActivityHistoryEntry = currentProcess.getHistory().getLastEntry(callActivityToken.position);\r\n\r\n    createBPMNProcess(\r\n        callActivityToken.calledProcessId,\r\n        processDefinition,\r\n        handler,\r\n        currentProcess.persistency,\r\n        currentProcess,\r\n        callActivityToken,\r\n        callActivityHistoryEntry,\r\n        function(err, calledProcess){\r\n            if(err){\r\n                return callback(err);\r\n            }\r\n\r\n            currentProcess.registerCalledProcess(calledProcess);\r\n\r\n            callback(null, calledProcess);\r\n        }\r\n    );\r\n};\r\n\r\n/**\r\n * @param {BPMNProcess} currentProcess\r\n * @return {Function | Object}\r\n */\r\nBPMNCallActivity.prototype.getHandler = function(currentProcess) {\r\n    var handler, bpmnFilePath;\r\n    var callActivityName = this.name;\r\n    var mockupHandler = handlerModule.getHandlerFromProcess(callActivityName, currentProcess);\r\n\r\n    if (mockupHandler && typeof mockupHandler === \"object\") {\r\n        handler = mockupHandler;\r\n    } else {\r\n        bpmnFilePath = this.location;\r\n        handler = handlerModule.getHandlerFromFile(bpmnFilePath);\r\n    }\r\n\r\n    assignHandler(handler, \"defaultEventHandler\", currentProcess);\r\n    assignHandler(handler, \"defaultErrorHandler\", currentProcess);\r\n    assignHandler(handler, \"doneSavingHandler\", currentProcess);\r\n    assignHandler(handler, \"doneLoadingHandler\", currentProcess);\r\n    assignHandler(handler, \"onBeginHandler\", currentProcess);\r\n    assignHandler(handler, \"onEndHandler\", currentProcess);\r\n\r\n    return handler;\r\n};\r\n\r\nfunction assignHandler(handler, name, currentProcess) {\r\n    // If the handler is explicitly given, we use it.\r\n    // Otherwise we use the handler of the current process which is the parent of the called process\r\n    handler[name] = handler[name] || currentProcess[name];\r\n}\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNCallActivity.prototype.validate = function(processDefinition, errorQueue) {\r\n    this.assertName(errorQueue);\r\n    this.assertIncomingSequenceFlows(processDefinition, errorQueue);\r\n    this.assertOutgoingSequenceFlows(processDefinition, errorQueue);\r\n\r\n    if (!this.location || this.location === '') {\r\n        errorQueue.addError(\"CA1\", this, \"The \" + this.type + \" '\" + this.name + \"' must reference another process by its file name.\");\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/events.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isMessageEventName = function(localName) {\r\n    return (localName === \"messageEventDefinition\");\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/intermediateEvents.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar parserUtils = require(\"./parserUtils.js\");\r\nvar BPMNFlowObject = require(\"./flowObject.js\").BPMNFlowObject;\r\n\r\n/**\r\n * @param node\r\n * @return {BPMNIntermediateThrowEvent}\r\n */\r\nexports.createBPMNIntermediateThrowEvent = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n    return (new BPMNIntermediateThrowEvent(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isIntermediateThrowEventName = function(localName) {\r\n    return (localName === \"intermediateThrowEvent\");\r\n};\r\n\r\n/**\r\n * Subsumes all kind of end events\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNIntermediateThrowEvent = exports.BPMNIntermediateThrowEvent = function(bpmnId, name, type) {\r\n    BPMNFlowObject.call(this, bpmnId, name, type);\r\n    this.isIntermediateThrowEvent = true;\r\n};\r\nutil.inherits(BPMNIntermediateThrowEvent, BPMNFlowObject);\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNIntermediateThrowEvent.prototype.validate = function(processDefinition, errorQueue) {\r\n    validateIntermediateEvent(this, processDefinition, errorQueue);\r\n};\r\n\r\n/**\r\n * @param node\r\n * @return {BPMNIntermediateCatchEvent}\r\n */\r\nexports.createBPMNIntermediateCatchEvent = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n    return (new BPMNIntermediateCatchEvent(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isIntermediateCatchEventName = function(localName) {\r\n    return (localName === \"intermediateCatchEvent\");\r\n};\r\n\r\n/**\r\n * Subsumes all kind of end events\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @constructor\r\n */\r\nvar BPMNIntermediateCatchEvent = exports.BPMNIntermediateCatchEvent = function(bpmnId, name, type) {\r\n    BPMNFlowObject.call(this, bpmnId, name, type);\r\n    this.isIntermediateCatchEvent = true;\r\n};\r\nutil.inherits(BPMNIntermediateCatchEvent, BPMNFlowObject);\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNIntermediateCatchEvent.prototype.validate = function(processDefinition, errorQueue) {\r\n    validateIntermediateEvent(this, processDefinition, errorQueue);\r\n};\r\n\r\n/**\r\n * @param {BPMNIntermediateCatchEvent | BPMNIntermediateThrowEvent} event\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nfunction validateIntermediateEvent(event, processDefinition, errorQueue) {\r\n    event.assertName(errorQueue);\r\n    event.assertIncomingSequenceFlows(processDefinition, errorQueue);\r\n    event.assertOneOutgoingSequenceFlow(processDefinition, errorQueue);\r\n}","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/subProcess.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar parserUtils = require(\"./parserUtils\");\r\nvar handler = require('../handler.js');\r\n\r\nvar BPMNActivity = require(\"./activity.js\").BPMNActivity;\r\nvar BPMNCallActivity = require(\"./callActivity.js\").BPMNCallActivity;\r\n\r\n/**\r\n * @param node\r\n * @param {BPMNProcessDefinition} subProcessDefinition\r\n */\r\nexports.createBPMNSubProcess = function(node, subProcessDefinition) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n\r\n    return (new BPMNSubProcess(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local,\r\n        subProcessDefinition\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isSubProcessName = function(localName) {\r\n    return (localName.toLowerCase().indexOf(\"subprocess\") > -1);\r\n};\r\n\r\n/**\r\n * Subsumes all kind of tasks\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @param {BPMNProcessDefinition} subProcessDefinition\r\n * @constructor\r\n */\r\n var BPMNSubProcess = exports.BPMNSubProcess = function(bpmnId, name, type, subProcessDefinition) {\r\n    BPMNActivity.call(this, bpmnId, name, type);\r\n    this.isSubProcess = true;\r\n    this.processDefinition = subProcessDefinition;\r\n};\r\nutil.inherits(BPMNSubProcess, BPMNActivity);\r\n\r\n\r\n/**\r\n * Semantics: If we are to enter a called processing (returningFromSubProcess = false), the called process is\r\n *            created and a token is put onto its start state. If we leave the subProcess we just emit a token.\r\n * @param {BPMNProcess} currentProcess\r\n * @param {Object} data\r\n * @param {Function} createBPMNProcess\r\n * @param {Boolean=} returningFromCalledProcess\r\n */\r\nBPMNSubProcess.prototype.emitTokens = function(currentProcess, data, createBPMNProcess, returningFromCalledProcess) {\r\n    // A sub-process is a special case of a call activity:\r\n    // the process is defined inline instead of being defined in another file\r\n    BPMNCallActivity.prototype.emitTokens.call(this, currentProcess, data, createBPMNProcess, returningFromCalledProcess);\r\n};\r\n\r\n/**\r\n * @param {Token} callActivityToken\r\n * @param {BPMNProcess} currentProcess\r\n * @param {Function} createBPMNProcess\r\n * @param {Function} callback\r\n */\r\nBPMNSubProcess.prototype.createCalledProcess = function(callActivityToken, currentProcess, createBPMNProcess, callback) {\r\n    var processDefinition = this.processDefinition;\r\n    // A sub-process is a special case of a call activity:\r\n    // the process is defined inline instead of being defined in another file\r\n    BPMNCallActivity.prototype.createCalledProcess.call(\r\n        this, callActivityToken, currentProcess, createBPMNProcess, processDefinition, callback);\r\n};\r\n\r\n/**\r\n * @param {BPMNProcess} currentProcess\r\n * @return {Function | Object}\r\n */\r\nBPMNSubProcess.prototype.getHandler = function(currentProcess) {\r\n    var subProcessName = this.name;\r\n    return handler.getHandlerFromProcess(subProcessName, currentProcess);\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {BPMNParseErrorQueue} errorQueue\r\n */\r\nBPMNSubProcess.prototype.validate = function(processDefinition, errorQueue) {\r\n    this.assertName(errorQueue);\r\n    this.assertIncomingSequenceFlows(processDefinition, errorQueue);\r\n    this.assertOutgoingSequenceFlows(processDefinition, errorQueue);\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/messageFlows.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar parserUtils = require(\"./parserUtils\");\r\n\r\n/**\r\n * @param node\r\n * @constructor\r\n */\r\nexports.createBPMNMessageFlow = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n    return (new BPMNMessageFlow(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local,\r\n        getValue(node, \"sourceRef\"),\r\n        getValue(node, \"targetRef\")\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isMessageFlowName = function(localName) {\r\n    return (localName.toLowerCase().indexOf(\"messageflow\") > -1);\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @param {String} sourceRef\r\n * @param {String} targetRef\r\n * @constructor\r\n */\r\nvar BPMNMessageFlow = exports.BPMNMessageFlow = function(bpmnId, name, type, sourceRef, targetRef) {\r\n    this.bpmnId = bpmnId;\r\n    this.name = name;\r\n    this.type = type;\r\n    this.sourceRef = sourceRef;\r\n    this.targetRef = targetRef;\r\n    this.targetProcessDefinitionId = null;\r\n    this.sourceProcessDefinitionId = null;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/participant.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar parserUtils = require(\"./parserUtils\");\r\n\r\n/**\r\n * @param node\r\n * @constructor\r\n */\r\nexports.createBPMNParticipant = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n    return (new BPMNParticipant(\r\n        getValue(node, \"id\"),\r\n        getValue(node, \"name\"),\r\n        node.local,\r\n        getValue(node, \"processRef\")\r\n    ));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isParticipantName = function(localName) {\r\n    return (localName === 'participant');\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @param {String} name\r\n * @param {String} type\r\n * @param {String} processRef\r\n * @constructor\r\n */\r\nvar BPMNParticipant = exports.BPMNParticipant = function(bpmnId, name, type, processRef) {\r\n    this.bpmnId = bpmnId;\r\n    this.name = name;\r\n    this.type = type;\r\n    this.processRef = processRef;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/collaborationDefinition.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar parserUtils = require(\"./parserUtils\");\r\n\r\n/**\r\n * @param node\r\n * @return {BPMNCollaborationDefinition}\r\n */\r\nexports.createBPMNCollaborationDefinition = function(node) {\r\n    var getValue = parserUtils.getAttributesValue;\r\n    return (new BPMNCollaborationDefinition(getValue(node, \"id\")));\r\n};\r\n\r\n/**\r\n * @param localName name without namespace prefix\r\n * @return {Boolean}\r\n */\r\nexports.isCollaborationDefinitionName = function(localName) {\r\n    return (localName === \"collaboration\");\r\n};\r\n\r\n/**\r\n * @param {String} bpmnId\r\n * @constructor\r\n */\r\nvar BPMNCollaborationDefinition = exports.BPMNCollaborationDefinition = function(bpmnId) {\r\n    this.bpmnId = bpmnId;\r\n    this.participants = [];\r\n    this.messageFlows = [];\r\n    this.isCollaborationDefinition = true;\r\n};\r\n\r\n/**\r\n * @param {BPMNParticipant} participant\r\n */\r\nBPMNCollaborationDefinition.prototype.addParticipant = function(participant) {\r\n   this.participants.push(participant);\r\n};\r\n\r\n/**\r\n * @param {String} processBbpmnId\r\n * @return {BPMNParticipant}\r\n */\r\nBPMNCollaborationDefinition.prototype.getParticipantByProcessId = function(processBbpmnId) {\r\n    var participants = this.participants.filter(function(participant) {\r\n        return (participant.processRef === processBbpmnId);\r\n    });\r\n    if (participants.length > 1) {\r\n        throw new Error(\"Cannot uniquely assign a pool to the process whith the BPMN ID '\" + processBbpmnId + \"'\");\r\n    }\r\n    return participants[0];\r\n};\r\n\r\n/**\r\n * Get all participants the process is collaborating with\r\n * @param {String} processBbpmnId\r\n * @return {Array.<BPMNParticipant>}\r\n */\r\nBPMNCollaborationDefinition.prototype.getCollaboratingParticipants = function(processBbpmnId) {\r\n    return this.participants.filter(function(participant) {\r\n        return (participant.processRef !== processBbpmnId);\r\n    });\r\n};\r\n\r\n/**\r\n * @param {BPMNMessageFlow} messageFlow\r\n */\r\nBPMNCollaborationDefinition.prototype.addMessageFlow = function(messageFlow) {\r\n    this.messageFlows.push(messageFlow);\r\n};\r\n\r\n/**\r\n * @return {Array.<BPMNMessageFlow>}\r\n */\r\nBPMNCollaborationDefinition.prototype.getMessageFlows = function() {\r\n    return this.messageFlows;\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/parsing/errors.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * @param {string} code\r\n * @param {{bpmnId: string, name: string, type: string}} bpmnElement\r\n * @param {string} description\r\n * @constructor\r\n */\r\nfunction BPMNParseError(code, bpmnElement, description){\r\n    this.code = code;\r\n    this.description = description;\r\n    if (bpmnElement) { // = null, if we cannot parse the file, for example\r\n        this.bpmnId = bpmnElement.bpmnId || \"Unknown\";\r\n        this.bpmnName = bpmnElement.name || \"\";\r\n        this.bpmnType = bpmnElement.type || \"Unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * @param {String=} fileName\r\n * @return {BPMNParseErrorQueue}\r\n */\r\nexports.createBPMNParseErrorQueue = function (fileName) {\r\n    return (new BPMNParseErrorQueue(fileName));\r\n};\r\n\r\n/**\r\n * @param {String=} fileName\r\n * @constructor\r\n */\r\nvar BPMNParseErrorQueue = function(fileName) {\r\n    /** @tpe {Array.<BuildError>} */\r\n    this.bpmnParseErrors = [];\r\n    this.fileName = fileName;\r\n};\r\n\r\n/**\r\n * @param {string} code\r\n * @param {{bpmnId: string, name: string, type: string}} bpmnElement\r\n * @param {string} description\r\n */\r\nBPMNParseErrorQueue.prototype.addError = function addError(code, bpmnElement, description) {\r\n   this.bpmnParseErrors.push(new BPMNParseError(code, bpmnElement, description));\r\n};\r\n\r\n/**\r\n * @return {Array.<BPMNParseError>}\r\n */\r\nBPMNParseErrorQueue.prototype.getErrors = function getErrors() {\r\n    return this.bpmnParseErrors;\r\n};\r\n\r\n/**\r\n *\r\n * @param {function(BPMNParseError)} reportFunction\r\n */\r\nBPMNParseErrorQueue.prototype.reportErrors = function reportErrors(reportFunction) {\r\n    var errors = this.getErrors();\r\n    errors.forEach(function(error) {\r\n        reportFunction(error);\r\n    });\r\n};\r\n\r\n/**\r\n * @return {int}\r\n */\r\nBPMNParseErrorQueue.prototype.getNumberOfErrors = function getNumberOfErrors() {\r\n    return this.bpmnParseErrors.length;\r\n};\r\n\r\n/**\r\n * @return {Boolean}\r\n */\r\nBPMNParseErrorQueue.prototype.hasErrors = function hasErrors() {\r\n    return (this.getNumberOfErrors() > 0);\r\n};\r\n\r\nBPMNParseErrorQueue.prototype.clear = function clearErrors() {\r\n    this.bpmnParseErrors = [];\r\n};\r\n\r\nBPMNParseErrorQueue.prototype.throwError = function throwErrors() {\r\n    // call built-in Error object to get stack and other properties required by the test framework\r\n    var error = new Error();\r\n\r\n    // mix-in relevant properties\r\n    error.bpmnParseErrors = this.bpmnParseErrors;\r\n    error.reportErrors = this.reportErrors;\r\n    error.getNumberOfErrors = this.getNumberOfErrors;\r\n    error.getErrors = this.getErrors;\r\n\r\n    throw error;\r\n};\r\n\r\nBPMNParseErrorQueue.prototype.check = function checkErrors() {\r\n    if (this.hasErrors()) {\r\n         this.throwError();\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/process.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\nvar async = require('async');\r\n\r\nvar _s = require('underscore.string');\r\nvar definitions = require('./parsing/definitions.js');\r\nvar handler = require('./handler.js');\r\nvar log = require('./logger.js');\r\n\r\nvar transactionLog = null;\r\ntry {\r\n    transactionLog = require('e2e-transaction-logger');\r\n}catch(err){\r\n    transactionLog = null;\r\n}\r\n\r\nvar EventEmitter = require('events').EventEmitter;\r\nvar BPMNProcessState = require(\"./state.js\").BPMNProcessState;\r\nvar BPMNProcessHistory = require(\"./history.js\").BPMNProcessHistory;\r\nvar BPMNProcessClient = require(\"./client.js\").BPMNProcessClient;\r\nvar BPMNPendingTimerEvents = require(\"./timeouts.js\").BPMNPendingTimerEvents;\r\n\r\nvar activityEndHandlerPostfix = require('./parsing/activity.js').activityEndHandlerPostfix;\r\n\r\nvar TOKEN_ARRIVED_EVENT = \"TOKEN_ARRIVED_EVENT\";\r\nvar ACTIVITY_END_EVENT = \"ACTIVITY_END_EVENT\";\r\nvar INTERMEDIATE_CATCH_EVENT = \"INTERMEDIATE_CATCH_EVENT\";\r\nvar BOUNDARY_CATCH_EVENT = \"BOUNDARY_CATCH_EVENT\";\r\n\r\n/**\r\n * Internal creation. The process is created and try to load persisted data.\r\n * @param {String} id\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {Object} eventHandler This object should contain event handler for all BPMN events\r\n * @param {Persistency=} persistency\r\n * @param {BPMNProcess=} parentProcess\r\n * @param {Token=} parentToken\r\n * @param {HistoryEntry=} parentHistoryEntry\r\n * @param {Function=} callback\r\n * @return {BPMNProcess}\r\n */\r\nvar createBPMNProcess = exports.createBPMNProcess = function(id, processDefinition, eventHandler, persistency, parentProcess, parentToken, parentHistoryEntry, callback) {\r\n    var bpmnProcess;\r\n\r\n    if(typeof persistency === 'function' ){\r\n        callback = persistency;\r\n        persistency = null;\r\n        parentProcess = null;\r\n        parentToken = null;\r\n        parentHistoryEntry = null;\r\n    } else if(typeof parentProcess === 'function' ){\r\n        callback = parentProcess;\r\n        parentProcess = null;\r\n        parentToken = null;\r\n        parentHistoryEntry = null;\r\n    } else if(typeof parentToken === 'function' ){\r\n        callback = parentToken;\r\n        parentToken = null;\r\n        parentHistoryEntry = null;\r\n    } else if(typeof parentHistoryEntry === 'function' ){\r\n        callback = parentHistoryEntry;\r\n        parentHistoryEntry = null;\r\n    }\r\n\r\n    if(!callback){\r\n        return;\r\n    }\r\n\r\n    bpmnProcess = new BPMNProcess(id, processDefinition, eventHandler, persistency, parentProcess, parentToken, parentHistoryEntry);\r\n\r\n    if (bpmnProcess.isMainProcess()) {\r\n        // we save all process information - including called processes - in one document\r\n        bpmnProcess.loadPersistedData(function(err){\r\n            if(callback){\r\n                callback(err, bpmnProcess);\r\n            }\r\n        });\r\n    } else {\r\n        if(callback){\r\n            process.nextTick(function(){        // to stay consistent\r\n                callback(null, bpmnProcess);\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @param {String} id\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @param {Object} eventHandler This object should contain event handler for all BPMN events\r\n * @param {Persistency=} persistency\r\n * @param {BPMNProcess=} parentProcess\r\n * @param {Token=} parentToken\r\n * @param {HistoryEntry=} parentHistoryEntry\r\n * @constructor\r\n */\r\nfunction BPMNProcess(id, processDefinition, eventHandler, persistency, parentProcess, parentToken, parentHistoryEntry) {\r\n    var self = this;\r\n    var defaultEventHandler, defaultErrorHandler;\r\n\r\n    this.processId = id;\r\n    this.processDefinition = processDefinition;\r\n    this.eventHandler = eventHandler;\r\n    this.parentProcess = parentProcess;\r\n    this.pendingTimerEvents = new BPMNPendingTimerEvents(this);\r\n    this.persistency = persistency;\r\n    this.deferredEvents = [];\r\n    this.deferEvents = false; // events must be deferred if the process engine is loading or saving state\r\n    this.processClient = new BPMNProcessClient(this);\r\n    this.participants = {}; // if the process takes part in a collaboration, we store all participant process in this map\r\n    this.properties = {}; // TODO: how do we handle parent data?\r\n    this.calledProcesses = {};\r\n    this.logger = new log.Logger(this, {logLevel: log.logLevels.error});\r\n    if(transactionLog) {\r\n        this.transactionLogger = new transactionLog.TransactionLogger();\r\n    }\r\n    this.currentTrx = null;\r\n    this.views = {\r\n        startEvent : null,\r\n        endEvent : null,\r\n        duration : null\r\n    };\r\n\r\n    if (parentToken) {\r\n        this.state = new BPMNProcessState(parentToken.substate);\r\n        parentToken.substate = this.state;\r\n        this.parentToken = parentToken;\r\n    } else {\r\n        this.state = new BPMNProcessState();\r\n    }\r\n\r\n    if (parentHistoryEntry) {\r\n        this.history = new BPMNProcessHistory(parentHistoryEntry.subhistory);\r\n        parentHistoryEntry.subhistory = this.history;\r\n    } else {\r\n        this.history = new BPMNProcessHistory();\r\n    }\r\n\r\n    defaultErrorHandler = logDefaultedErrors;\r\n    defaultEventHandler = function(eventType, currentFlowObjectName, handlerName, reason, done) {\r\n        if (done) {\r\n            done.call(self.processClient);\r\n        }\r\n    };\r\n\r\n    eventHandler = eventHandler || {};\r\n    this.defaultEventHandler = eventHandler.defaultEventHandler || defaultEventHandler;\r\n    this.defaultErrorHandler = eventHandler.defaultErrorHandler || defaultErrorHandler;\r\n    this.doneSavingHandler = eventHandler.doneSavingHandler;\r\n    this.doneLoadingHandler = eventHandler.doneLoadingHandler;\r\n    this.onBeginHandler = eventHandler.onBeginHandler;\r\n    this.onEndHandler = eventHandler.onEndHandler;\r\n\r\n    this._registerOnTokenArrivedEvent();\r\n    this._registerActivityEndEvents();\r\n    this._registerThrowIntermediateEvents();\r\n    this._registerThrowBoundaryEvents();\r\n}\r\nutil.inherits(BPMNProcess, EventEmitter);\r\n\r\n/**\r\n * @returns {Boolean}\r\n */\r\nBPMNProcess.prototype.isMainProcess = function() {\r\n    return  (this.parentProcess === undefined || this.parentProcess === null);\r\n};\r\n\r\n/**\r\n * @returns {BPMNProcessDefinition}\r\n */\r\nBPMNProcess.prototype.getProcessDefinition = function() {\r\n    return this.processDefinition;\r\n};\r\n\r\n/**\r\n * @returns {String}\r\n */\r\nBPMNProcess.prototype.getProcessId = function() {\r\n    return this.processId;\r\n};\r\n\r\n/**\r\n * @param {Logger} logger\r\n */\r\nBPMNProcess.prototype.setLogger = function(logger) {\r\n    this.logger = logger;\r\n};\r\n\r\n/**\r\n * @param {number | string} logLevel\r\n */\r\nBPMNProcess.prototype.setLogLevel = function(logLevel) {\r\n    this.logger.setLogLevel(logLevel);\r\n};\r\n\r\n/**\r\n * @param {function(string)} logAppender\r\n */\r\nBPMNProcess.prototype.setLogAppender = function(logAppender) {\r\n    this.logger.logAppender = logAppender;\r\n};\r\n\r\n/**\r\n * Add winston log transport (semantic like winston add() [https://github.com/flatiron/winston])\r\n * @param winstonTransport\r\n * @param options\r\n */\r\nBPMNProcess.prototype.addLogTransport = function(winstonTransport, options) {\r\n    this.logger.addTransport(winstonTransport, options);\r\n};\r\n\r\n/**\r\n * Remove winston log transport (semantic like winston remove() [https://github.com/flatiron/winston])\r\n * @param winstonTransport\r\n */\r\nBPMNProcess.prototype.removeLogTransport = function(winstonTransport) {\r\n    this.logger.removeTransport(winstonTransport);\r\n};\r\n\r\n/**\r\n * @returns {Transaction}\r\n */\r\nBPMNProcess.prototype.getCurrentTrx = function() {\r\n    return this.currentTrx;\r\n};\r\n\r\n/**\r\n * @param {String} eventName\r\n * @param {Object=} data\r\n */\r\nBPMNProcess.prototype.triggerEvent = function(eventName, data) {\r\n    var self = this;\r\n    var processDefinition = self.processDefinition;\r\n    var flowObjectName = eventName;\r\n    var flowObject = processDefinition.getFlowObjectByName(flowObjectName);\r\n    var taskDoneMatch = _s.endsWith(eventName, activityEndHandlerPostfix);\r\n\r\n    if (flowObject) {\r\n\r\n        this.logger.trace(\"Trigger \" + flowObject.type + \" '\" + flowObject.name + \"'\", data);\r\n\r\n        if (flowObject.isStartEvent) {\r\n            if (self.history.hasBeenVisited(eventName)) {\r\n                 throw new Error(\"The start event '\" + eventName + \"' cannot start an already started process.\");\r\n            } else {\r\n                // start events create a token and put it on the first occurrence\r\n                self._putTokenAt(flowObject, data);\r\n            }\r\n        } else if (flowObject.isIntermediateCatchEvent) {\r\n            process.nextTick(function() {\r\n                // We need this to achieve parallel collaborating processes\r\n                // TODO: however, it is not completely clear to me whether this works in all circumstances\r\n                self._emitEvent(INTERMEDIATE_CATCH_EVENT, eventName, data);\r\n            });\r\n        } else if (flowObject.isBoundaryEvent) {\r\n            self._emitEvent(BOUNDARY_CATCH_EVENT, eventName, data);\r\n        } else {\r\n            throw new Error(\"The process '\" + processDefinition.name + \"' has no intermediate catch event for '\" + eventName + \"'\");\r\n        }\r\n    } else if (taskDoneMatch){\r\n        flowObjectName = _s.strLeft(eventName, activityEndHandlerPostfix);\r\n        flowObject = processDefinition.getFlowObjectByName(flowObjectName);\r\n\r\n        if(flowObject && flowObject.isWaitTask){\r\n            self.taskDone(flowObjectName, data);\r\n        }else{\r\n            throw new Error(\"The process '\" + processDefinition.name + \"' does not know the event '\" + eventName + \"'\");\r\n        }\r\n    } else {\r\n        throw new Error(\"The process '\" + processDefinition.name + \"' does not know the event '\" + eventName + \"'\");\r\n    }\r\n };\r\n\r\n/**\r\n * Send a message by name to this process or along a message flow\r\n * @param {BPMNMessageFlow | String} messageFlow\r\n * @param {Object=} data\r\n */\r\nBPMNProcess.prototype.sendMessage = function(messageFlow, data) {\r\n    var self = this;\r\n\r\n    if (typeof messageFlow === 'string') {\r\n        this.triggerEvent(messageFlow, data);\r\n    } else {\r\n        if (messageFlow.targetProcessDefinitionId) {\r\n            this.getParticipantById(messageFlow.targetProcessDefinitionId, function(err, partnerProcess) {\r\n                var targetFlowObject = partnerProcess.processDefinition.getFlowObject(messageFlow.targetRef);\r\n                var sourceFlowObject = self.processDefinition.getSourceFlowObject(messageFlow);\r\n\r\n                self.logger.trace(\"Sending '\" +\r\n                    messageFlow.name + \"' from '\" +\r\n                    sourceFlowObject.name + \"' to '\" +\r\n                    targetFlowObject.name + \"'.\", data);\r\n\r\n                partnerProcess.triggerEvent(targetFlowObject.name, data);\r\n            });\r\n        } else {\r\n            throw new Error(\"sendMessage: the '\" + messageFlow.name + \"' has no targetProcessDefinitionId. Is the message flow target an executable pool?\");\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @param {String} taskName\r\n * @param {Object} data\r\n */\r\nBPMNProcess.prototype.taskDone = function(taskName, data) {\r\n    this.logger.trace(\"Task '\" + taskName + \"' done.\", data);\r\n    this.emitActivityEndEvent(taskName, data);\r\n};\r\n\r\n/**\r\n * @param {String} participantName\r\n * @return {BPMNProcess}\r\n */\r\nBPMNProcess.prototype.getParticipantByName = function(participantName, callback) {\r\n    callback(null, this.participants[participantName]);\r\n};\r\n\r\n/**\r\n * @param {String} processDefinitionId\r\n * @return {BPMNProcess}\r\n */\r\nBPMNProcess.prototype.getParticipantById = function(processDefinitionId, callback) {\r\n    var participant = this.processDefinition.getParticipantById(processDefinitionId);\r\n\r\n    callback(null, this.participants[participant.name]);\r\n};\r\n\r\n/**\r\n * @param {String} participantName\r\n * @param {BPMNProcess} bpmnProcess\r\n */\r\nBPMNProcess.prototype.addParticipant = function(participantName, bpmnProcess) {\r\n    this.participants[participantName] = bpmnProcess;\r\n};\r\n\r\n/**\r\n * @return {BPMNProcess}\r\n */\r\nBPMNProcess.prototype.getParentProcess = function() {\r\n    return this.parentProcess;\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} currentFlowObject\r\n * @param {Object=} data\r\n */\r\nBPMNProcess.prototype._putTokenAt = function(currentFlowObject, data) {\r\n    var self = this;\r\n    var name = currentFlowObject.name;\r\n\r\n    self.state.createTokenAt(name, self.processId);\r\n    self.logger.debug(\"Token was put on '\" + name + \"'\", data);\r\n    self.onFlowObjectBegin(currentFlowObject, data, function() {\r\n        self._emitEvent(TOKEN_ARRIVED_EVENT, name, data);\r\n    });\r\n};\r\n\r\n/**\r\n * @param {String} currentFlowObjectName\r\n * @param {Function} done\r\n */\r\nBPMNProcess.prototype._notifyBPMNEditor = function(currentFlowObjectName, done) {\r\n    var self = this;\r\n    var debuggerInterface = self.processDefinition.debuggerInterface;\r\n    var flowObject = self.processDefinition.getFlowObjectByName(currentFlowObjectName);\r\n    if (debuggerInterface && flowObject) {\r\n        debuggerInterface.sendPosition(flowObject, self.logger, done);\r\n    } else {\r\n        done();\r\n    }\r\n};\r\n\r\n/**\r\n * @param {Function} done\r\n * @private\r\n */\r\nBPMNProcess.prototype._clearBPMNEditorState = function(done) {\r\n    var self = this;\r\n    var debuggerInterface = self.processDefinition.debuggerInterface;\r\n    if (debuggerInterface) {\r\n        debuggerInterface.sendPosition({}, self.logger, done);\r\n    } else {\r\n        done();\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * @param {Function} callback\r\n */\r\nBPMNProcess.prototype.onTokenArrivedEvent = function(callback) {\r\n    this.on(TOKEN_ARRIVED_EVENT, callback);\r\n};\r\n\r\n/**\r\n * @return {BPMNProcessState}\r\n */\r\nBPMNProcess.prototype.getState = function() {\r\n    return this.state;\r\n};\r\n\r\n/**\r\n * @return {BPMNProcessHistory}\r\n */\r\nBPMNProcess.prototype.getHistory = function() {\r\n    return this.history;\r\n};\r\n\r\n/**\r\n * @return {*}\r\n */\r\nBPMNProcess.prototype.getProperties = function() {\r\n    return this.properties;\r\n};\r\n\r\n/**\r\n * @param {Boolean=} closeConnection\r\n */\r\nBPMNProcess.prototype.persist = function(closeConnection) {\r\n    var mainProcess, doneSaving, persistentData;\r\n    var persistency = this.persistency;\r\n\r\n    if (persistency) {\r\n        this.setDeferEvents(true);\r\n        mainProcess = this.getMainProcess();\r\n        doneSaving = function(error, savedData) {\r\n            if (error) {\r\n                mainProcess.logger.error(\"Cannot persist process '\" + mainProcess.processId +\r\n                    \"'. Process name: '\" + mainProcess.processDefinition.name + \"'. Error: \" + error);\r\n\r\n                if (mainProcess.doneSavingHandler) {\r\n                    mainProcess.doneSavingHandler.call(mainProcess.processClient, error);\r\n                }\r\n            } else {\r\n                if (mainProcess.doneSavingHandler) {\r\n                    mainProcess.doneSavingHandler.call(mainProcess.processClient, null, savedData);\r\n                }\r\n\r\n                mainProcess.logger.debug(\"SavedData: \", savedData);\r\n\r\n                if (closeConnection) {\r\n                    persistency.close(function() {\r\n                        mainProcess._emitDeferredEvents();\r\n                    });\r\n                } else {\r\n                    mainProcess._emitDeferredEvents();\r\n                }\r\n            }\r\n         };\r\n\r\n        persistentData = {\r\n            processName: mainProcess.processDefinition.name,\r\n            processId: mainProcess.processId,\r\n            parentToken: mainProcess.parentToken || null,\r\n            properties: mainProcess.properties,\r\n            state: mainProcess.state,\r\n            history: mainProcess.history,\r\n            pendingTimeouts: mainProcess.pendingTimerEvents.pendingTimeouts,\r\n            views: mainProcess.views\r\n        };\r\n        persistency.persist(persistentData, doneSaving);\r\n    }\r\n};\r\n\r\n/**\r\n * If we have a persistency layer that requires db connections, they are closed.\r\n * @param {Function} done\r\n */\r\nBPMNProcess.prototype.closeConnection = function(done) {\r\n    var persistency = this.persistency;\r\n    if (persistency) {\r\n        persistency.close(done);\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * @returns {BPMNProcess}\r\n */\r\nBPMNProcess.prototype.getMainProcess = function() {\r\n    var mainProcess;\r\n    if (this.parentProcess) {\r\n        mainProcess = this.parentProcess.getMainProcess();\r\n    } else {\r\n        mainProcess = this;\r\n    }\r\n    return mainProcess;\r\n};\r\n\r\n/**\r\n * @returns {Boolean}\r\n */\r\nBPMNProcess.prototype.hasToDeferEvents = function() {\r\n    var mainProcess = this.getMainProcess();\r\n    return mainProcess.deferEvents;\r\n };\r\n\r\n/**\r\n * @param {Boolean} deferEvents\r\n */\r\nBPMNProcess.prototype.setDeferEvents = function(deferEvents) {\r\n    var mainProcess = this.getMainProcess();\r\n    mainProcess.deferEvents = deferEvents;\r\n};\r\n\r\n/**\r\n */\r\nBPMNProcess.prototype.loadPersistedData = function(callback) {\r\n    var mainProcess, processId, processName, doneLoading;\r\n\r\n    if(typeof callback !== 'function'){\r\n        callback = function(){};\r\n    }\r\n\r\n    if (this.persistency) {\r\n        this.setDeferEvents(true);\r\n        mainProcess = this.getMainProcess();\r\n        processId = mainProcess.processId;\r\n        processName = mainProcess.processDefinition.name;\r\n        doneLoading = function(error, loadedData) {\r\n\r\n            if (error) {\r\n                mainProcess.logger.error(\"Cannot load process '\" + mainProcess.processId +\r\n                    \"'. Process name: '\" + processName + \"'. Error: \" + error);\r\n                if (mainProcess.doneLoadingHandler) {\r\n                    mainProcess.doneLoadingHandler.call(mainProcess.processClient, error, loadedData);\r\n                }\r\n                callback(error, loadedData);\r\n            } else {\r\n                if (loadedData) {\r\n                    try{\r\n                        mainProcess.setPersistedData(loadedData);\r\n                    } catch (error2) {\r\n                        mainProcess.logger.error(\"Cannot load process '\" + mainProcess.processId +\r\n                            \"'. Process name: '\" + processName + \"'. Error: \" + error2);\r\n                        if (mainProcess.doneLoadingHandler) {\r\n                            mainProcess.doneLoadingHandler.call(mainProcess.processClient, error2, loadedData);\r\n                        }\r\n                        return callback(error2, loadedData);\r\n                    }\r\n\r\n                    mainProcess.createCalledProcesses(function(error3){\r\n                        if(error3){\r\n                            mainProcess.logger.error(\"Cannot load process '\" + mainProcess.processId +\r\n                                \"'. Process name: '\" + processName + \"'. Error: \" + error3);\r\n                            if (mainProcess.doneLoadingHandler) {\r\n                                mainProcess.doneLoadingHandler.call(mainProcess.processClient, error3, loadedData);\r\n                            }\r\n                            return callback(error3, loadedData);\r\n                        }\r\n\r\n                        if (mainProcess.doneLoadingHandler) {\r\n                            mainProcess.doneLoadingHandler.call(mainProcess.processClient, null, loadedData);\r\n                        }\r\n\r\n                        mainProcess._emitDeferredEvents();\r\n                        callback(null, loadedData);\r\n                    });\r\n\r\n                }else{\r\n                    mainProcess._emitDeferredEvents();\r\n                    callback(null, loadedData);\r\n                }\r\n            }\r\n\r\n        };\r\n        mainProcess.persistency.load(processId, processName, doneLoading);\r\n    }else{\r\n        if(callback){\r\n            process.nextTick(function(){        // to stay consistent\r\n                callback();\r\n            });\r\n        }\r\n    }\r\n\r\n};\r\n\r\n/**\r\n */\r\nBPMNProcess.prototype.createCalledProcesses = function(callback) {\r\n    var self = this;\r\n    var callActivityTokens = self.state.findCallActivityTokens();\r\n\r\n    if(typeof callback !== 'function'){\r\n        callback = function(){};\r\n    }\r\n\r\n    async.each(callActivityTokens, function(callActivityToken, done){\r\n        var callActivityName = callActivityToken.position;\r\n        var callActivity = self.processDefinition.getFlowObjectByName(callActivityName);\r\n        callActivity.createCalledProcess(callActivityToken, self, createBPMNProcess, function(err, calledProcess){\r\n            if(err){\r\n                done(err);\r\n            }\r\n            calledProcess.createCalledProcesses(done);\r\n        });\r\n    }, callback);\r\n\r\n};\r\n\r\nBPMNProcess.prototype.setPersistedData = function(loadedData) {\r\n    this.state = new BPMNProcessState(loadedData.state);\r\n    this.history = new BPMNProcessHistory(loadedData.history);\r\n    this.pendingTimerEvents = new BPMNPendingTimerEvents(this);\r\n    this.pendingTimerEvents.restoreTimerEvents(loadedData.pendingTimeouts);\r\n    this.properties = loadedData.properties || {};\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @param {Object} value\r\n */\r\nBPMNProcess.prototype.setProperty = function(name, value) {\r\n    this.properties[name] = value;\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @return {Object}\r\n */\r\nBPMNProcess.prototype.getProperty = function(name) {\r\n    return this.properties[name];\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} currentFlowObject\r\n * @param {Object} data\r\n * @param {Boolean=} returningFromCalledProcess\r\n * @private\r\n */\r\nBPMNProcess.prototype._emitTokens = function(currentFlowObject, data, returningFromCalledProcess) {\r\n    var activity;\r\n    var self = this;\r\n\r\n    self.state.removeTokenAt(currentFlowObject);\r\n\r\n    if (currentFlowObject.isBoundaryEvent) {\r\n        activity = self.processDefinition.getFlowObject(currentFlowObject.attachedToRef);\r\n        self._clearBoundaryTimerEvents(activity);\r\n        self.state.removeTokenAt(activity);\r\n        self.onFlowObjectEnd(activity.name);\r\n    } else {\r\n        self._clearBoundaryTimerEvents(currentFlowObject);\r\n    }\r\n\r\n    if (currentFlowObject.isCallActivity || currentFlowObject.isSubProcess) {\r\n        currentFlowObject.emitTokens(self, data, createBPMNProcess, returningFromCalledProcess);\r\n    } else {\r\n        currentFlowObject.emitTokens(self, data);\r\n    }\r\n};\r\n\r\n/**\r\n * @param {String} eventName\r\n * @param {Object} data\r\n * @private\r\n */\r\nBPMNProcess.prototype.emitActivityEndEvent = function(eventName, data) {\r\n    this._emitEvent(ACTIVITY_END_EVENT, eventName, data);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} currentFlowObject\r\n * @param {BPMNSequenceFlow} outgoingSequenceFlow\r\n * @param {Object} data\r\n */\r\nBPMNProcess.prototype.emitTokenAlong = function(currentFlowObject, outgoingSequenceFlow, data) {\r\n    var nextFlowObject = this.processDefinition.getProcessElement(outgoingSequenceFlow.targetRef);\r\n    this._putTokenAt(nextFlowObject, data);\r\n};\r\n\r\n/**\r\n * @returns {Boolean}\r\n */\r\nBPMNProcess.prototype.isDebuggerEnabled = function() {\r\n    var debuggerInterface = this.processDefinition.debuggerInterface;\r\n    return (debuggerInterface && debuggerInterface.isInDebugger());\r\n};\r\n\r\n/**\r\n * Called on begin of activities, task, catch events, etc.\r\n * @param {BPMNFlowObject} currentFlowObject\r\n * @param {Object} data\r\n * @param {Function} done\r\n * @private\r\n */\r\nBPMNProcess.prototype.onFlowObjectBegin = function(currentFlowObject, data, done) {\r\n    var self = this;\r\n    var name = currentFlowObject.name;\r\n\r\n    var finished = function() {\r\n        if (self.onBeginHandler) {\r\n            self.onBeginHandler.call(self.processClient, name, data, function() {\r\n                done();\r\n            });\r\n        } else {\r\n            done();\r\n        }\r\n    };\r\n\r\n    self.history.addEntry(currentFlowObject);\r\n\r\n    if(currentFlowObject.isStartEvent) {\r\n        self.views.startEvent = self.history.historyEntries[0];\r\n    }\r\n\r\n    if (self.isDebuggerEnabled()) {\r\n        this._notifyBPMNEditor(name, finished);\r\n    } else {\r\n        finished();\r\n    }\r\n};\r\n\r\n/**\r\n * Called on end of activities, task, catch events, etc.\r\n * @param {String} currentFlowObjectName\r\n * @param {Object=} data\r\n * @param {Function=} done\r\n */\r\nBPMNProcess.prototype.onFlowObjectEnd = function(currentFlowObjectName, data, done) {\r\n    var self = this;\r\n    var history = self.history;\r\n\r\n    var finished = function() {\r\n        history.setEnd(currentFlowObjectName);\r\n        if(history.isFinished()){\r\n            self.views.duration = history.finishedAt - history.createdAt;\r\n        }\r\n        // NOTE: done() MUST be called AFTER setEnd() because in done() the token is send to the next flowObjects\r\n        if (done) {\r\n            done();\r\n        }\r\n    };\r\n\r\n    if (self.onEndHandler) {\r\n        self.onEndHandler.call(self.processClient, currentFlowObjectName, data, finished);\r\n    } else {\r\n        finished();\r\n    }\r\n};\r\n\r\n/**\r\n * Called on end of processes (also called processes)\r\n * @param {String} endEventName\r\n * @param {Boolean=} isMainProcess\r\n * @param {Function=} done\r\n */\r\nBPMNProcess.prototype.onProcessEnd = function(endEventName, isMainProcess, done) {\r\n    var self = this;\r\n    var history = self.getHistory();\r\n\r\n    var finished = function() {\r\n        if (done) {\r\n            done();\r\n        }\r\n        if (isMainProcess) {\r\n            self.views.endEvent = history.getLastEntry(endEventName);\r\n            // no parent implies we finish the main process\r\n            // TODO: need a way to tell the outside in order to delete the object.\r\n            // emit event ?\r\n            // pass the manager to the process ?\r\n            // pass a function that will be called here ?\r\n            self.persist(true);\r\n        }\r\n    };\r\n\r\n    if (self.isDebuggerEnabled()) {\r\n        self._clearBPMNEditorState(finished);\r\n    } else {\r\n        finished();\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNProcess} calledProcess\r\n */\r\nBPMNProcess.prototype.registerCalledProcess = function(calledProcess) {\r\n    var calledProcessId = calledProcess.processId;\r\n    this.calledProcesses[calledProcessId] = calledProcess;\r\n};\r\n\r\n/**\r\n * @param {String} calledProcessId\r\n */\r\nBPMNProcess.prototype.unregisterCalledProcess = function(calledProcessId) {\r\n    delete this.calledProcesses[calledProcessId];\r\n};\r\n\r\n/**\r\n * @param {BPMNActivity} currentActivity\r\n * @private\r\n */\r\nBPMNProcess.prototype._registerBoundaryTimerEvents = function(currentActivity) {\r\n    var self = this;\r\n    var boundaryEvents = this.processDefinition.getBoundaryEventsAt(currentActivity);\r\n\r\n    boundaryEvents.forEach(function(boundaryEvent) {\r\n        if (boundaryEvent.isTimerEvent) {\r\n            self.pendingTimerEvents.addBoundaryTimerEvent(boundaryEvent);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param {BPMNIntermediateCatchEvent} timerEvent\r\n * @private\r\n */\r\nBPMNProcess.prototype._registerIntermediateTimerEvents = function(timerEvent) {\r\n    this.pendingTimerEvents.addIntermediateTimerEvent(timerEvent);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} currentFlowObject\r\n * @private\r\n */\r\nBPMNProcess.prototype._clearBoundaryTimerEvents = function(currentFlowObject) {\r\n    var self = this;\r\n    var boundaryEvents = this.processDefinition.getBoundaryEventsAt(currentFlowObject);\r\n\r\n    boundaryEvents.forEach(function(boundaryEvent) {\r\n        if (boundaryEvent.isTimerEvent) {\r\n            self.pendingTimerEvents.removeTimeout(boundaryEvent.name);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nBPMNProcess.prototype._registerActivityEndEvents = function() {\r\n    var self = this;\r\n\r\n    self.on(ACTIVITY_END_EVENT, function(activityName, data) {\r\n        var currentToken, owningProcessId, currentProcess, currentFlowObject, activityEndHandlerIsDone;\r\n        var handlerName = handler.mapName2HandlerName(activityName) + activityEndHandlerPostfix;\r\n        var trx = self.currentTrx = null;\r\n\r\n        if(self.transactionLogger){\r\n            trx = self.currentTrx = self.transactionLogger.startTransaction(self.processDefinition.name, 'PSTATE', 'TRANSITION', null, activityName+'Done');\r\n        }\r\n\r\n        if (self.state.hasTokens(activityName)) {\r\n            currentToken = self.state.getFirstToken(activityName);\r\n            owningProcessId = currentToken.owningProcessId;\r\n            currentProcess = owningProcessId === self.processId ? self : self.calledProcesses[owningProcessId];\r\n            currentFlowObject = currentProcess.processDefinition.getFlowObjectByName(currentToken.position);\r\n            activityEndHandlerIsDone = function(data) {\r\n                if(trx) {\r\n                    trx.processStateEnd(self.processDefinition.name, self.getProcessId(), activityName);\r\n                    trx.end();\r\n                }\r\n                self.logger.trace(\"Calling done() of '\" + handlerName + \"'.\");\r\n                currentProcess._emitTokens(currentFlowObject, data, true);\r\n            };\r\n            self.logger.trace(\"Calling '\" + handlerName + \"' for \" + ACTIVITY_END_EVENT + \" '\" + activityName + \"'.\");\r\n            handler.callHandler(handlerName, currentProcess, data, activityEndHandlerIsDone);\r\n        } else {\r\n            self.callDefaultEventHandler(ACTIVITY_END_EVENT, activityName, handlerName,\r\n                \"Process cannot handle this activity because it is not currently executed.\",\r\n                function(){\r\n                    if(trx){\r\n                        trx.end();\r\n                    }\r\n                });\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nBPMNProcess.prototype._registerThrowIntermediateEvents = function() {\r\n    var self = this;\r\n\r\n    self.on(INTERMEDIATE_CATCH_EVENT, function(eventName, data) {\r\n        var catchIntermediateEventObject, eventCaughtHandler;\r\n        var handlerName = handler.mapName2HandlerName(eventName);\r\n        var trx = self.currentTrx = null;\r\n\r\n        if(self.transactionLogger){\r\n            trx = self.currentTrx = self.transactionLogger.startTransaction(self.processDefinition.name, 'PSTATE', 'TRANSITION', null, eventName);\r\n        }\r\n\r\n        if (self.state.hasTokens(eventName)) {\r\n            if(trx) {\r\n                trx.processEvent(self.processDefinition.name, self.getProcessId(), eventName);\r\n            }\r\n            catchIntermediateEventObject = self.processDefinition.getFlowObjectByName(eventName);\r\n            eventCaughtHandler = function(data) {\r\n                if(trx){\r\n                    trx.end();\r\n                }\r\n                self.logger.trace(\"Calling done() of '\" + handlerName + \"'.\");\r\n                self._emitTokens(catchIntermediateEventObject, data, true);\r\n            };\r\n            self.logger.trace(\"Calling '\" + handlerName + \"' for \" + INTERMEDIATE_CATCH_EVENT + \" '\" + eventName + \"'.\");\r\n            handler.callHandler(handlerName, self, data, eventCaughtHandler);\r\n        } else {\r\n            self.callDefaultEventHandler(INTERMEDIATE_CATCH_EVENT, eventName, handlerName, \"Process cannot handle the intermediate event ' + \" +\r\n                eventName + \"' because the process '\" + self.processDefinition.name + \"' doesn't expect one.\",\r\n                function(){\r\n                    if(trx){\r\n                        trx.end();\r\n                    }\r\n                });\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nBPMNProcess.prototype._registerThrowBoundaryEvents = function() {\r\n    var self = this;\r\n\r\n    self.on(BOUNDARY_CATCH_EVENT, function(eventName, data) {\r\n        var handlerName = handler.mapName2HandlerName(eventName);\r\n        var catchBoundaryEventObject = self.processDefinition.getFlowObjectByName(eventName);\r\n        var activity = self.processDefinition.getFlowObject(catchBoundaryEventObject.attachedToRef);\r\n        var trx = self.currentTrx = null;\r\n\r\n        if(self.transactionLogger){\r\n            trx = self.currentTrx = self.transactionLogger.startTransaction(self.processDefinition.name, 'PSTATE', 'TRANSITION', null, eventName);\r\n        }\r\n\r\n        self.logger.trace(\"Catching boundary event '\" + eventName + \"' done.\", data);\r\n\r\n        if (self.state.hasTokensAt(activity)) {\r\n            if(trx) {\r\n                trx.processStateEnd(self.processDefinition.name, self.getProcessId(), activity.name);\r\n            }\r\n            self.state.removeTokenAt(activity);\r\n            self._putTokenAt(catchBoundaryEventObject, data);\r\n        } else {\r\n            self.callDefaultEventHandler(BOUNDARY_CATCH_EVENT, eventName, handlerName, \"Process cannot handle the boundary event '\" +\r\n                eventName + \"' because the activity '\" + activity.name + \"' doesn't expect one.\",\r\n                function(){\r\n                    if(trx) {\r\n                        trx.end();\r\n                    }\r\n                });\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nBPMNProcess.prototype._registerOnTokenArrivedEvent = function() {\r\n    var self = this;\r\n\r\n    self.onTokenArrivedEvent(function(currentFlowObjectName, data) {\r\n        var handlerDone;\r\n        var currentFlowObject = self.processDefinition.getFlowObjectByName(currentFlowObjectName);\r\n        var trx = self.currentTrx;\r\n\r\n        self.logger.debug(\"Token arrived at \" + currentFlowObject.type + \" '\" + currentFlowObject.name + \"'\", data);\r\n        if (currentFlowObject.isIntermediateCatchEvent) {\r\n            // all intermediate event handlers are called WHEN the event occurs\r\n            // TODO: should we change this?\r\n            if (currentFlowObject.isTimerEvent) {\r\n                self._registerIntermediateTimerEvents(currentFlowObject);\r\n            }\r\n            self.persist();\r\n        } else {\r\n            handlerDone = function(data) {\r\n                if (currentFlowObject.isWaitTask) {\r\n                    if(trx){\r\n                        trx.end();\r\n                    }\r\n                    self._registerBoundaryTimerEvents(currentFlowObject);\r\n                    self.persist();\r\n                } else if (currentFlowObject.isCallActivity || currentFlowObject.isSubProcess) {\r\n                    if(trx){\r\n                        trx.end();\r\n                    }\r\n                    self._registerBoundaryTimerEvents(currentFlowObject);\r\n                    self._emitTokens(currentFlowObject, data);\r\n                } else if(currentFlowObject.isActivity) {\r\n                    if(trx) {\r\n                        trx.processStateEnd(self.processDefinition.name, self.getProcessId(), currentFlowObjectName);\r\n                        trx.end();\r\n                    }\r\n                    self._emitTokens(currentFlowObject, data);\r\n                } else if (currentFlowObject.isExclusiveGateway) {\r\n                    self._emitTokens(currentFlowObject, data);\r\n                } else {\r\n                    if(trx){\r\n                        trx.end();\r\n                    }\r\n                    self._emitTokens(currentFlowObject, data);\r\n                }\r\n            };\r\n\r\n            if(currentFlowObject.isBoundaryEvent && trx){\r\n                if(trx) {\r\n                    trx.processEvent(self.processDefinition.name, self.getProcessId(), currentFlowObjectName);\r\n                }\r\n            }else{\r\n                if(self.transactionLogger) {\r\n                    trx = self.currentTrx = self.transactionLogger.startTransaction(self.processDefinition.name, 'PSTATE', 'TRANSITION', null, currentFlowObjectName);\r\n\r\n                    if (currentFlowObject.isActivity) {\r\n                        trx.processStateStart(self.processDefinition.name, self.getProcessId(), currentFlowObjectName);\r\n                    } else if (currentFlowObject.isIntermediateThrowEvent) {\r\n                        trx.processEvent(self.processDefinition.name, self.getProcessId(), currentFlowObjectName);\r\n                    } else if (currentFlowObject.isStartEvent) {\r\n                        trx.processStart(self.processDefinition.name, self.getProcessId(), currentFlowObjectName);\r\n                    } else if (currentFlowObject.isEndEvent) {\r\n                        trx.processEnd(self.processDefinition.name, self.getProcessId(), currentFlowObjectName);\r\n                    }\r\n                }\r\n            }\r\n\r\n            handler.callHandler(currentFlowObjectName, self, data, handlerDone);\r\n        }\r\n     });\r\n};\r\n\r\n/**\r\n * @param {String} eventType\r\n * @param {String} eventName\r\n * @param data\r\n * @private\r\n */\r\nBPMNProcess.prototype._emitEvent = function(eventType, eventName, data) {\r\n    data = data || {};\r\n    if (this.hasToDeferEvents()) {\r\n        this.deferredEvents.push({type: eventType, name: eventName, data: data});\r\n    } else {\r\n        this.emit(eventType, eventName, data);\r\n    }\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nBPMNProcess.prototype._emitDeferredEvents = function() {\r\n    var self = this;\r\n\r\n    this.setDeferEvents(false); // we have to reset this flag, otherwise the deferred events we try to emit now would be deferred again!\r\n    this.deferredEvents.forEach(function(event) {\r\n        self.logger.trace(\"Emitting deferred events \" + event.type + \" '\" + event.name + \"'\", event.data);\r\n        process.nextTick(function(){\r\n            self.emit(event.type, event.name, event.data)\r\n        });\r\n    });\r\n    this.deferredEvents = [];\r\n};\r\n\r\n/**\r\n * @param {String} eventType\r\n * @param {String?} currentFlowObjectName\r\n * @param {String} handlerName\r\n * @param {String} reason\r\n * @param {Function=} done\r\n */\r\nBPMNProcess.prototype.callDefaultEventHandler = function(eventType, currentFlowObjectName, handlerName, reason, done) {\r\n    this.logger.trace(\"Unhandled event: '\" + eventType + \"' for '\" + currentFlowObjectName + \"'. Handler: \" + handlerName + \"'. Reason: \" + reason);\r\n    this.defaultEventHandler.call(this.processClient, eventType, currentFlowObjectName, handlerName, reason, done);\r\n};\r\n\r\n/**\r\n * @param {{toString, stack}} error\r\n */\r\nfunction logDefaultedErrors(error) {\r\n    console.log(\"Unhandled error: '\" + error + \"' Stack trace: \" + error.stack);\r\n}\r\n\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/logger.js":"/**\r\n * Copyright: E2E Technologies Ltd.\r\n */\r\n\"use strict\";\r\n\r\nvar winston = require('winston');\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nvar logLevels = exports.logLevels = {\r\n        silly: 0, // winston\r\n        verbose: 1, // winston\r\n        info: 2, // winston\r\n        warn: 3, // winston\r\n        debug: 4, // winston\r\n        trace: 5,\r\n        error: 6, // winston\r\n        none: 7\r\n};\r\n\r\nvar logLevelColors = {\r\n    silly: 'yellow',\r\n    verbose: 'blue',\r\n    info: 'green',\r\n    warn: 'orange',\r\n    debug: 'black', // does not work in WebStorm\r\n    trace: 'grey',\r\n    error: 'red'\r\n};\r\n\r\n/**\r\n * @param {BPMNProcess=} process\r\n * @param {{logLevel: number}} options\r\n * @constructor\r\n */\r\nvar Logger = exports.Logger = function(process, options) {\r\n    this.logLevel = logLevels.error;\r\n    if (options) {\r\n        this.logLevel = getLogLevelValue(options.logLevel || this.logLevel);\r\n    }\r\n\r\n    /** {function(string)} */\r\n    this.logAppender = null; // used for example to test log messages\r\n\r\n    this.winstonFileTransport = new (winston.transports.File)({\r\n        //level: getLogLevelString(this.logLevel), //TODO: this should work, but it doesn't. Why?\r\n        level: 'verbose',\r\n        filename: './process.log',\r\n        maxsize: 64 * 1024 * 1024,\r\n        maxFiles: 100,\r\n        timestamp: function() {\r\n            return Date.now();\r\n        }\r\n    });\r\n    this.winstonConsoleTransport = new (winston.transports.Console)({\r\n        //level: getLogLevelString(this.logLevel), //TODO: this should work, but it doesn't. Why?\r\n        level: 'verbose',\r\n        colorize: true,\r\n        json: false\r\n    });\r\n    this.winstonLogger = new (winston.Logger)({\r\n        transports: [this.winstonFileTransport, this.winstonConsoleTransport],\r\n        levels: logLevels,\r\n        colors: logLevelColors\r\n    });\r\n\r\n    this.setProcess(process);\r\n};\r\n\r\n// All log levels are available as logger methods\r\nObject.keys(logLevels).forEach(function(logLevelName) {\r\n    Logger.prototype[logLevelName] = function(description, data) {\r\n        this.log(logLevels[logLevelName], description, data);\r\n    };\r\n});\r\n\r\n/**\r\n * @param {BPMNProcessClient|BPMNProcess} bpmnProcess\r\n */\r\nLogger.prototype.setProcess = function(bpmnProcess) {\r\n    if (bpmnProcess) {\r\n        this.processDefinition = bpmnProcess.getProcessDefinition();\r\n        this.processId = bpmnProcess.getProcessId();\r\n        bpmnProcess.setLogger(this);\r\n    } else {\r\n        this.processDefinition = {};\r\n        this.processId = \"unknown\";\r\n    }\r\n};\r\n\r\n/**\r\n * @param {number | string} logLevel\r\n */\r\nLogger.prototype.setLogLevel = function(logLevel) {\r\n    var levelValue = getLogLevelValue(logLevel);\r\n    var levelName = getLogLevelString(levelValue);\r\n\r\n    this.logLevel = levelValue;\r\n    this.winstonConsoleTransport.level = levelName;\r\n    this.winstonFileTransport.level = levelName;\r\n};\r\n\r\n/**\r\n * Add winston log transport (semantic like winston add() [https://github.com/flatiron/winston])\r\n * @param WinstonTransport\r\n * @param options\r\n */\r\nLogger.prototype.addTransport = function(WinstonTransport, options) {\r\n    var name = WinstonTransport.prototype.name;\r\n    var winstonTransportObject = (new WinstonTransport(options));\r\n\r\n    if (name === 'file') {\r\n        this.winstonLogger.remove(WinstonTransport);\r\n        this.winstonFileTransport = winstonTransportObject;\r\n    } else if (name === 'console') {\r\n        this.winstonLogger.remove(WinstonTransport);\r\n        this.winstonConsoleTransport = winstonTransportObject;\r\n    }\r\n    this.winstonLogger.add(winstonTransportObject, options, true);\r\n};\r\n\r\n/**\r\n * Remove winston log transport (semantic like winston remove() [https://github.com/flatiron/winston])\r\n * @param winstonTransport\r\n */\r\nLogger.prototype.removeTransport = function(winstonTransport) {\r\n    this.winstonLogger.remove(winstonTransport);\r\n};\r\n\r\n    /**\r\n * @param {number} logLevel\r\n * @param {String} description\r\n * @param {Object=} data\r\n */\r\nLogger.prototype.log = function(logLevel, description, data) {\r\n    var processId, processName, dataMessage, formattedMessage, messageObject;\r\n\r\n    if (logLevel >= this.logLevel) {\r\n        processId = this.processId || \"unknown\";\r\n        processName = this.processDefinition ? this.processDefinition.name : \"unknown\";\r\n\r\n        if (this.logAppender) {\r\n\r\n            dataMessage = data ? \"[\" + getMessageString(data) + \"]\" : \"\";\r\n            formattedMessage = \"[\" + getLogLevelString(logLevel) + \"][\" + processName + \"][\" + processId + \"][\" + description + \"]\" + dataMessage;\r\n            this.logAppender(formattedMessage);\r\n\r\n        } else {\r\n\r\n            messageObject = {\r\n                process: processName,\r\n                id: processId,\r\n                description: description\r\n            };\r\n            if (data) {\r\n                messageObject.data = data;\r\n            }\r\n            this.winstonLogger.log(getLogLevelString(logLevel), messageObject, function(error) {\r\n                if (error) {\r\n                    console.log(\"Error while logging: \" + error);\r\n                }\r\n            });\r\n\r\n        }\r\n    }\r\n};\r\n\r\nfunction getLogLevelString(logLevel) {\r\n    var result = \"unknown\";\r\n    var keys = Object.keys(logLevels);\r\n\r\n    keys.forEach(function(key) {\r\n        if (logLevels[key] === logLevel) {\r\n            result = key;\r\n        }\r\n    });\r\n    return result;\r\n}\r\n\r\n/**\r\n * @param {number | string} logLevel\r\n * @return number\r\n */\r\nfunction getLogLevelValue(logLevel) {\r\n    var logLevelValue;\r\n\r\n    if (typeof logLevel === 'string') {\r\n        logLevelValue = logLevels[logLevel] || logLevels.error;\r\n    } else {\r\n        logLevelValue = logLevel;\r\n    }\r\n    return logLevelValue;\r\n}\r\n\r\nfunction getMessageString(data) {\r\n    return (typeof data === 'object' ? JSON.stringify(data) : data.toString());\r\n}","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/state.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar util = require('util');\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @param {String} owningProcessId\r\n * @constructor\r\n */\r\nvar Token = exports.Token = function(flowObjectName, owningProcessId) {\r\n    this.position = flowObjectName;\r\n    this.owningProcessId = owningProcessId;\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @param {String} owningProcessId\r\n * @param {String} calledProcessId\r\n * @constructor\r\n */\r\nvar CallActivityToken = exports.CallActivityToken = function(flowObjectName, owningProcessId, calledProcessId) {\r\n    Token.call(this, flowObjectName, owningProcessId);\r\n    this.substate = null;\r\n    this.calledProcessId = calledProcessId;\r\n};\r\nutil.inherits(CallActivityToken, Token);\r\n\r\n/**\r\n * @param {BPMNProcessState} state For explicit given states. For example, after loading persisted state\r\n * @constructor\r\n */\r\nvar BPMNProcessState = exports.BPMNProcessState = function(state) {\r\n    /** @type {Array.<Token>} */\r\n    this.tokens = state && state.tokens ? state.tokens : [];\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @param {String} owningProcessId\r\n * @param {String=} calledProcessId\r\n * @return {Token}\r\n */\r\nBPMNProcessState.prototype.createTokenAt = function(flowObjectName, owningProcessId, calledProcessId) {\r\n    var newToken;\r\n\r\n    if (calledProcessId) {\r\n        newToken = new CallActivityToken(flowObjectName, owningProcessId, calledProcessId);\r\n    } else {\r\n        newToken = new Token(flowObjectName, owningProcessId);\r\n    }\r\n    this.tokens.push(newToken);\r\n\r\n    return newToken;\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @return {Array.<Token>}\r\n */\r\nBPMNProcessState.prototype.findTokens = function(flowObjectName) {\r\n    var foundTokens = [];\r\n    findTokens(flowObjectName, this.tokens, foundTokens);\r\n    return foundTokens;\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @param {Array.<Token>} currentTokens\r\n * @param {Array.<Token>} foundTokens\r\n */\r\nfunction findTokens(flowObjectName, currentTokens, foundTokens) {\r\n    currentTokens.forEach(function(token) {\r\n        if (token.position === flowObjectName) {\r\n            foundTokens.push(token);\r\n        }\r\n        if (token.substate) {\r\n            findTokens(flowObjectName, token.substate.tokens, foundTokens);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @return {Array.<Token>}\r\n */\r\nBPMNProcessState.prototype.findCallActivityTokens = function() {\r\n    var foundTokens = [];\r\n\r\n    this.tokens.forEach(function(token) {\r\n        if (token.calledProcessId) {\r\n            foundTokens.push(token);\r\n        }\r\n    });\r\n\r\n    return foundTokens;\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @return {Token}\r\n */\r\nBPMNProcessState.prototype.getFirstToken = function(flowObjectName) {\r\n    var tokensAtActivity = this.findTokens(flowObjectName);\r\n    return (tokensAtActivity && tokensAtActivity.length > 0 ? tokensAtActivity[0] : null);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n */\r\nBPMNProcessState.prototype.removeTokenAt = function(flowObject) {\r\n    var tokenHasBeenRemoved = false;\r\n    var newTokens = [];\r\n    var oldTokens = this.tokens;\r\n\r\n    oldTokens.forEach(function(token) {\r\n        // we remove a token by copying all references except one token\r\n        if (tokenHasBeenRemoved) {\r\n            newTokens.push(token);\r\n        } else {\r\n            if (token.position === flowObject.name) {\r\n                tokenHasBeenRemoved = true;\r\n            } else {\r\n                newTokens.push(token);\r\n            }\r\n        }\r\n    });\r\n\r\n    this.tokens = newTokens;\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n */\r\nBPMNProcessState.prototype.removeAllTokensAt = function(flowObject) {\r\n    var newTokens = [];\r\n    var oldTokens = this.tokens;\r\n\r\n    oldTokens.forEach(function(token) {\r\n        if (token.position !== flowObject.name) {\r\n            newTokens.push(token);\r\n        }\r\n    });\r\n\r\n    this.tokens = newTokens;\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Boolean}\r\n */\r\nBPMNProcessState.prototype.hasTokensAt = function(flowObject) {\r\n    return (flowObject ? this.hasTokens(flowObject.name) : false);\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @return {Boolean}\r\n */\r\nBPMNProcessState.prototype.hasTokens = function(flowObjectName) {\r\n    var tokens = this.findTokens(flowObjectName);\r\n    return (tokens.length > 0);\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n * @return {Number}\r\n */\r\nBPMNProcessState.prototype.numberOfTokensAt = function(flowObject) {\r\n    var count = 0;\r\n\r\n    if (flowObject) {\r\n        this.tokens.forEach(function(token) {\r\n            if (flowObject.name === token.position) {\r\n                count++;\r\n            }\r\n        });\r\n    }\r\n\r\n    return count;\r\n};\r\n\r\n\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/history.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar endEvents = require('./parsing/endEvents.js');\r\n\r\nvar getTimestamp = Date.now;\r\nexports.setTimestampFunction = function(getTimestampFunction) {\r\n    getTimestamp = getTimestampFunction;\r\n};\r\nexports.setDummyTimestampFunction = function() {\r\n    getTimestamp = function () { return \"_dummy_ts_\"; };\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @param {String} type\r\n * @param {Number=} begin Timestamp in ms\r\n * @param {Number=} end\r\n * @constructor\r\n */\r\nvar HistoryEntry = exports.HistoryEntry = function(name, type, begin, end) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.begin = begin || getTimestamp();\r\n    this.end = end || null;\r\n};\r\n\r\nHistoryEntry.prototype.setEnd = function() {\r\n    this.end = getTimestamp();\r\n};\r\n\r\n/**\r\n * @param {BPMNProcessHistory} history For explicit given history. For example, after loading persisted state\r\n * @constructor\r\n */\r\nvar BPMNProcessHistory = exports.BPMNProcessHistory = function(history) {\r\n    /** @type {Array.<HistoryEntry>} */\r\n    this.historyEntries = [];\r\n\r\n    if (history) {\r\n        this.historyEntries = history.historyEntries.map(function(historyEntry) {\r\n            var entry = new HistoryEntry(historyEntry.name, historyEntry.type, historyEntry.begin, historyEntry.end);\r\n            if (historyEntry.subhistory) {\r\n                entry.subhistory = new BPMNProcessHistory(historyEntry.subhistory);\r\n            }\r\n            return entry;\r\n        });\r\n        this.createdAt = history.createdAt;\r\n        this.finishedAt = history.finishedAt || null;\r\n    } else {\r\n        this.createdAt = getTimestamp();\r\n        this.finishedAt = null;\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNFlowObject} flowObject\r\n */\r\nBPMNProcessHistory.prototype.addEntry = function(flowObject) {\r\n    this.historyEntries.push(new HistoryEntry(flowObject.name, flowObject.type));\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @return {HistoryEntry}\r\n */\r\nBPMNProcessHistory.prototype.getLastEntry = function(flowObjectName) {\r\n    var lastEntry = null;\r\n    var last =  this.historyEntries.length - 1;\r\n    var i;\r\n\r\n    for (i=last; i >= 0; i--) {\r\n        var entry = this.historyEntries[i];\r\n        if (entry.name === flowObjectName) {\r\n            lastEntry = entry;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return lastEntry;\r\n};\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n */\r\nBPMNProcessHistory.prototype.setEnd = function(flowObjectName) {\r\n    var historyEntry = this.getLastEntry(flowObjectName);\r\n    historyEntry.setEnd();\r\n    if (endEvents.isEndEventName(historyEntry.type)) {\r\n        this.finishedAt = historyEntry.end;\r\n    }\r\n};\r\n\r\nBPMNProcessHistory.prototype.isFinished = function() {\r\n    if(this.historyEntries.length){\r\n        return endEvents.isEndEventName(this.historyEntries[this.historyEntries.length - 1].type)\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * @param {String} flowObjectName\r\n * @return {Boolean}\r\n */\r\nBPMNProcessHistory.prototype.hasBeenVisited = function(flowObjectName) {\r\n    return hasBeenVisited(this.historyEntries, flowObjectName);\r\n};\r\n\r\nfunction hasBeenVisited(historyEntries, flowObjectName) {\r\n    var found = false;\r\n\r\n    historyEntries.forEach(function(entry) {\r\n        if (entry.name === flowObjectName) {\r\n            found = true;\r\n        }\r\n    });\r\n\r\n    if (!found) {\r\n        historyEntries.forEach(function(entry) {\r\n            if (entry.subhistory && hasBeenVisited(entry.subhistory.historyEntries, flowObjectName)) {\r\n                found = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    return found;\r\n}","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/client.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * @param {BPMNProcess} bpmnProcess\r\n * @constructor\r\n */\r\nvar BPMNProcessClient = exports.BPMNProcessClient = function(bpmnProcess) {\r\n    this._implementation = bpmnProcess;\r\n};\r\n\r\n/**\r\n * @return {BPMNProcess}\r\n * @private\r\n */\r\nBPMNProcessClient.prototype._getImplementation = function() {\r\n    return this._implementation;\r\n};\r\n\r\n/**\r\n * @param {String} taskName\r\n * @param {Object} data\r\n */\r\nBPMNProcessClient.prototype.taskDone = function(taskName, data) {\r\n    this._getImplementation().taskDone(taskName, data);\r\n};\r\n\r\n/**\r\n * @param {String} eventName\r\n * @param {Object=} data\r\n */\r\nBPMNProcessClient.prototype.triggerEvent = function(eventName, data) {\r\n    this._getImplementation().triggerEvent(eventName, data);\r\n};\r\n\r\n/**\r\n * @param {BPMNMessageFlow} messageFlow\r\n * @param {Object=} data\r\n */\r\nBPMNProcessClient.prototype.sendMessage = function(messageFlow, data) {\r\n    this._getImplementation().sendMessage(messageFlow, data);\r\n};\r\n\r\n/**\r\n * @param {String}sourceObjectFlowName\r\n * @return {Array.<BPMNMessageFlow>}\r\n */\r\nBPMNProcessClient.prototype.getOutgoingMessageFlows = function(sourceObjectFlowName) {\r\n    return this.getProcessDefinition().getMessageFlowsBySourceName(sourceObjectFlowName);\r\n};\r\n\r\n/**\r\n * @return {BPMNProcessState}\r\n */\r\nBPMNProcessClient.prototype.getState = function() {\r\n    return this._getImplementation().getState();\r\n};\r\n\r\n/**\r\n * @return {BPMNProcessHistory}\r\n */\r\nBPMNProcessClient.prototype.getHistory = function() {\r\n    return this._getImplementation().getHistory();\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @param {Object} value\r\n */\r\nBPMNProcessClient.prototype.setProperty = function(name, value) {\r\n    this._getImplementation().setProperty(name, value);\r\n};\r\n\r\n/**\r\n * @param {String} name\r\n * @return {Object}\r\n */\r\nBPMNProcessClient.prototype.getProperty = function(name) {\r\n    return this._getImplementation().getProperty(name);\r\n};\r\n\r\n/**\r\n * @return {Object}\r\n */\r\nBPMNProcessClient.prototype.getProperties = function() {\r\n    return this._getImplementation().getProperties();\r\n};\r\n\r\n/**\r\n * @return {BPMNProcessClient}\r\n */\r\nBPMNProcessClient.prototype.getParentProcess = function() {\r\n    return this._getImplementation().getParentProcess().processClient;\r\n};\r\n\r\n/**\r\n * @return {BPMNProcessDefinition}\r\n */\r\nBPMNProcessClient.prototype.getProcessDefinition = function() {\r\n    return this._getImplementation().getProcessDefinition();\r\n};\r\n\r\n/**\r\n * @return {String}\r\n */\r\nBPMNProcessClient.prototype.getProcessId = function() {\r\n    return this._getImplementation().getProcessId();\r\n};\r\n\r\n/**\r\n * @param {String} participantName\r\n * @return {BPMNProcessClient}\r\n */\r\nBPMNProcessClient.prototype.getParticipantByName = function(participantName, callback) {\r\n    this._getImplementation().getParticipantByName(participantName, function(err, bpmnProcess){\r\n        if(err){\r\n            return callback(err);\r\n        }\r\n\r\n        callback(null, bpmnProcess.processClient);\r\n    });\r\n};\r\n\r\n/**\r\n * @param {Logger} logger\r\n */\r\nBPMNProcessClient.prototype.setLogger = function(logger) {\r\n    this._getImplementation().setLogger(logger);\r\n};\r\n\r\n/**\r\n * @param {number | string} logLevel\r\n */\r\nBPMNProcessClient.prototype.setLogLevel = function(logLevel) {\r\n    this._getImplementation().setLogLevel(logLevel);\r\n};\r\n\r\n/**\r\n * Add winston log transport (semantic like winston add() [https://github.com/flatiron/winston])\r\n * @param winstonTransport\r\n * @param options\r\n */\r\nBPMNProcessClient.prototype.addLogTransport = function(winstonTransport, options) {\r\n    this._getImplementation().addLogTransport(winstonTransport, options);\r\n};\r\n\r\n/**\r\n * Remove winston log transport (semantic like winston remove() [https://github.com/flatiron/winston])\r\n * @param winstonTransport\r\n */\r\nBPMNProcessClient.prototype.removeLogTransport = function(winstonTransport) {\r\n    this._getImplementation().removeLogTransport(winstonTransport);\r\n};\r\n\r\n/**\r\n * @param {function(string)} logAppender\r\n */\r\nBPMNProcessClient.prototype.setLogAppender = function(logAppender) {\r\n    this._getImplementation().setLogAppender(logAppender);\r\n};\r\n\r\n/**\r\n * If we have a persistency layer that requires db connections, they are closed.\r\n * @param {Function} done\r\n */\r\n\r\nBPMNProcessClient.prototype.closeConnection = function(done) {\r\n    this._getImplementation().closeConnection(done);\r\n};\r\n\r\n/**\r\n * @return {Transaction}\r\n */\r\nBPMNProcessClient.prototype.getTrx = function() {\r\n    return this._getImplementation().getCurrentTrx();\r\n};\r\n\r\n/**\r\n *\r\n * @param {String} key\r\n * @param {String} value\r\n */\r\nBPMNProcessClient.prototype.traceString = function(key, value) {\r\n    if(this._getImplementation().getCurrentTrx()) {\r\n        this._getImplementation().getCurrentTrx().processValueString(\r\n            this._getImplementation().getProcessDefinition().name,\r\n            this._getImplementation().getProcessId(),\r\n            key,\r\n            value.toString());\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @param {String} key\r\n * @param {Number} value\r\n */\r\nBPMNProcessClient.prototype.traceFloat = function(key, value) {\r\n    value = Number(value);\r\n    if(!value){\r\n        value = 0;\r\n    }\r\n\r\n    if(this._getImplementation().getCurrentTrx()) {\r\n        this._getImplementation().getCurrentTrx().processValueFloat(\r\n            this._getImplementation().getProcessDefinition().name,\r\n            this._getImplementation().getProcessId(),\r\n            key,\r\n            value);\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @param {String} key\r\n * @param {Date|Number} value\r\n */\r\nBPMNProcessClient.prototype.traceDatetime = function(key, value) {\r\n    value = Number(value);\r\n    if(!value){\r\n        value = 0;\r\n    }\r\n\r\n    value = new Date(value);\r\n\r\n    if(this._getImplementation().getCurrentTrx()) {\r\n        this._getImplementation().getCurrentTrx().processValueDateTime(\r\n            this._getImplementation().getProcessDefinition().name,\r\n            this._getImplementation().getProcessId(),\r\n            key,\r\n            value);\r\n    }\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/timeouts.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar handler = require('./handler.js');\r\nvar getTimeoutHandlerPostfix = handler.handlerNameSeparator + \"getTimeout\";\r\n\r\n/**\r\n * @param {Integer} timeoutInMs\r\n * @param {Boolean} isRelative\r\n * @constructor\r\n */\r\nfunction Timeout(timeoutInMs, isRelative) {\r\n    var at, now;\r\n\r\n    if (isRelative) {\r\n        now = Date.now();\r\n        at = now + timeoutInMs;\r\n    } else {\r\n        at = timeoutInMs;\r\n    }\r\n\r\n    this.at = at;\r\n    this.timeout = timeoutInMs;\r\n}\r\n\r\n/**\r\n * @constructor\r\n */\r\nvar BPMNPendingTimerEvents = exports.BPMNPendingTimerEvents = function(bpmnProcess) {\r\n    /** @type {Array.<Timeout>} */\r\n    this.pendingTimeouts = {};\r\n    this.bpmnProcess = bpmnProcess;\r\n    this.setTimeoutIds = {};\r\n};\r\n\r\n/**\r\n * @return {Boolean}\r\n */\r\nBPMNPendingTimerEvents.prototype.hasTimeouts = function() {\r\n    return (Object.keys(this.pendingTimeouts).length > 0);\r\n};\r\n\r\n/**\r\n * @param {String} timerEventName\r\n * @return {Timeout}\r\n */\r\nBPMNPendingTimerEvents.prototype.getTimeout = function(timerEventName) {\r\n    return this.pendingTimeouts[timerEventName];\r\n};\r\n\r\n/**\r\n * @param {String} timerEventName\r\n */\r\nBPMNPendingTimerEvents.prototype.removeTimeout = function(timerEventName) {\r\n    if (this.pendingTimeouts[timerEventName]) {\r\n        delete this.pendingTimeouts[timerEventName];\r\n    }\r\n\r\n    if (this.setTimeoutIds[timerEventName]) {\r\n        clearTimeout(this.setTimeoutIds[timerEventName]);\r\n        delete this.setTimeoutIds[timerEventName];\r\n    }\r\n};\r\n\r\n/**\r\n * @param {Object} pendingTimeouts Object that maps timeout event names to timeouts\r\n */\r\nBPMNPendingTimerEvents.prototype.restoreTimerEvents = function(pendingTimeouts) {\r\n    var self = this;\r\n    var processDefinition = this.bpmnProcess.processDefinition;\r\n\r\n    if (pendingTimeouts) {\r\n        Object.keys(pendingTimeouts).forEach(function(timerEventName) {\r\n            var timerEvent = processDefinition.getFlowObjectByName(timerEventName);\r\n            if (timerEvent.isIntermediateCatchEvent) {\r\n                self.addIntermediateTimerEvent(timerEvent, pendingTimeouts[timerEventName]);\r\n            } else {\r\n                self.addBoundaryTimerEvent(timerEvent, pendingTimeouts[timerEventName]);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n/**\r\n * @param {BPMNBoundaryEvent} timerEvent\r\n * @param {Timeout=} pendingTimeout If given, this timeout object is added to the pending timeouts.\r\n *                                  If not given, a new timeout will be created.\r\n */\r\nBPMNPendingTimerEvents.prototype.addBoundaryTimerEvent = function(timerEvent, pendingTimeout) {\r\n    var bpmnProcess = this.bpmnProcess;\r\n    var self = this;\r\n    var timerEventName = timerEvent.name;\r\n    var timerEventHandler = function() {\r\n        bpmnProcess.logger.trace(\"Caught boundary timer event: '\" + timerEvent.name + \"'.\");\r\n        self.removeTimeout(timerEventName);\r\n        bpmnProcess._putTokenAt(timerEvent);\r\n    };\r\n\r\n    this.addTimerEvent(timerEventName, pendingTimeout, timerEventHandler);\r\n};\r\n\r\n/**\r\n * @param {BPMNIntermediateCatchEvent} timerEvent\r\n * @param {Timeout=} pendingTimeout If given, this object is added to the pending timeouts.\r\n *                                  If not given, a new timeout will be created.\r\n */\r\nBPMNPendingTimerEvents.prototype.addIntermediateTimerEvent = function(timerEvent, pendingTimeout) {\r\n    var bpmnProcess = this.bpmnProcess;\r\n    var self = this;\r\n    var timerEventName = timerEvent.name;\r\n    var timerEventHandler = function() {\r\n        var handlerDone;\r\n        var trx = bpmnProcess.currentTrx = null;\r\n\r\n        if(bpmnProcess.transactionLogger){\r\n            trx = bpmnProcess.currentTrx = bpmnProcess.transactionLogger.startTransaction(bpmnProcess.processDefinition.name, 'PSTATE', 'TRANSITION', null, timerEvent.name);\r\n            trx.processEvent(bpmnProcess.processDefinition.name, bpmnProcess.getProcessId(), timerEvent.name);\r\n        }\r\n\r\n        bpmnProcess.logger.trace(\"Caught intermediate timer event: '\" + timerEvent.name + \"'.\");\r\n        bpmnProcess.state.removeTokenAt(timerEvent);\r\n        self.removeTimeout(timerEventName);\r\n        handlerDone = function() {\r\n            if(trx){\r\n                trx.end();\r\n            }\r\n            timerEvent.emitTokens(bpmnProcess);\r\n        };\r\n        handler.callHandler(timerEventName, bpmnProcess, null, handlerDone);\r\n    };\r\n\r\n    this.addTimerEvent(timerEventName, pendingTimeout, timerEventHandler);\r\n};\r\n\r\n/**\r\n * @param {String} timerEventName\r\n * @param {Timeout=} pendingTimeout If given, this object is added to the pending timeouts.\r\n *                                  If not given, a new timeout will be created.\r\n * @param {Function=} timeoutEventHandler\r\n */\r\nBPMNPendingTimerEvents.prototype.addTimerEvent = function(timerEventName, pendingTimeout, timeoutEventHandler) {\r\n    var bpmnProcess = this.bpmnProcess;\r\n    var self = this;\r\n    var getTimeoutHandlerName = timerEventName + getTimeoutHandlerPostfix;\r\n    var timeoutInMs = handler.callHandler(getTimeoutHandlerName, bpmnProcess);\r\n    var timeout, now, diff;\r\n\r\n    if (isNaN(timeoutInMs)) {\r\n        throw new Error(\"The getTimeout handler '\" + getTimeoutHandlerName + \"' does not return a number but '\" + timeoutInMs + \"'\");\r\n    } else {\r\n        timeout = pendingTimeout || new Timeout(timeoutInMs, true);\r\n        self.pendingTimeouts[timerEventName] = timeout;\r\n\r\n        now = Date.now();\r\n        diff = timeout.at - now;\r\n        if (diff > 0) {\r\n            bpmnProcess.logger.debug(\"Set timer for '\" + timerEventName + \"'. Timeout: \" + diff);\r\n            self.setTimeoutIds[timerEventName] = setTimeout(timeoutEventHandler, diff);\r\n        } else {\r\n            timeoutEventHandler();\r\n        }\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/manager.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n * Author: Cyril Schmitt <cschmitt@e2ebridge.com>\r\n */\r\n\"use strict\";\r\n\r\nvar async = require('async');\r\nvar util = require('util');\r\n\r\nvar definitions = require('./parsing/definitions');\r\nvar handlers = require('./handler');\r\nvar Persistency = require('./persistency/persistency').Persistency;\r\nvar createBPMNProcess = require('./process').createBPMNProcess;\r\nvar find = require('./find');\r\nvar rest = require('./rest');\r\n\r\n/**\r\n * @param {{\r\n *      bpmnFilePath: String|Array.<String>=,\r\n *      handlerFilePath: {name: String, filePath: String}|Array.<{name: String, filePath: String}>=,\r\n *      handler: {name: String, module: Object}|Array.<{name: String, module: Object}>=,\r\n *      persistencyOptions: {uri: String, doneLoading: Function, doneSaving: Function}=\r\n *  }} options\r\n * @constructor\r\n */\r\nvar ProcessManager = exports.ProcessManager = function(options){\r\n    var self = this;\r\n\r\n    options = options || {};\r\n\r\n    self._processCache = {};\r\n\r\n    self._initialized = true;\r\n    self._initialising = false;\r\n    self._initializationError = null;\r\n    self._definitionsToInitialize = [];\r\n    self._initialiseCallbacks = [];\r\n\r\n    self._persistency = null;\r\n    if (options.persistencyOptions) {\r\n        self._persistency =  new Persistency(options.persistencyOptions);\r\n        self._doneLoadingHandler = options.persistencyOptions.doneLoading;\r\n        self._doneSavingHandler = options.persistencyOptions.doneSaving;\r\n    }\r\n\r\n    self._processHandlers = {};\r\n    self._processDefinitions = {};\r\n\r\n\r\n    if(!options.handlerFilePath){\r\n        options.handlerFilePath = [];\r\n    }\r\n\r\n    if(!util.isArray(options.handlerFilePath)){\r\n        options.handlerFilePath = [options.handlerFilePath];\r\n    }\r\n\r\n    options.handlerFilePath.forEach(function(handlerDescriptor){\r\n        if(!handlerDescriptor.name || !handlerDescriptor.filePath){\r\n            throw new Error(\"handlerFilePath needs a name and a filePath\");\r\n        }\r\n\r\n        self.addHandlerFilePath(handlerDescriptor.name, handlerDescriptor.filePath);\r\n    });\r\n\r\n\r\n    if(!options.handler){\r\n        options.handler = [];\r\n    }\r\n\r\n    if(!util.isArray(options.handler)){\r\n        options.handler = [options.handler];\r\n    }\r\n\r\n    options.handler.forEach(function(handlerDescriptor){\r\n        if(!handlerDescriptor.name || !handlerDescriptor.module){\r\n            throw new Error(\"handler needs a name and a module\");\r\n        }\r\n\r\n        self.addHandler(handlerDescriptor.name, handlerDescriptor.module);\r\n    });\r\n\r\n    if(!options.handlerString){\r\n        options.handlerString = [];\r\n    }\r\n\r\n    if(!util.isArray(options.handlerString)){\r\n        options.handlerString = [options.handlerString];\r\n    }\r\n\r\n    options.handlerString.forEach(function(handlerString){\r\n        if(!handlerString.name || !handlerString.string){\r\n            throw new Error(\"handlerString needs a name and a string\");\r\n        }\r\n\r\n        self.addHandlerString(handlerString.name, handlerString.string);\r\n    });\r\n\r\n\r\n    if(!options.bpmnFilePath){\r\n        options.bpmnFilePath = [];\r\n    }\r\n\r\n    if(!util.isArray(options.bpmnFilePath)){\r\n        options.bpmnFilePath = [options.bpmnFilePath];\r\n    }\r\n\r\n    options.bpmnFilePath.forEach(function(filePath){\r\n        self.addBpmnFilePath(filePath);\r\n    });\r\n\r\n\r\n    if(!options.bpmnXML){\r\n        options.bpmnXML = [];\r\n    }\r\n\r\n    if(!util.isArray(options.bpmnXML)){\r\n        options.bpmnXML = [options.bpmnXML];\r\n    }\r\n\r\n    options.bpmnXML.forEach(function(bpmnXML){\r\n        if(!bpmnXML.name || !bpmnXML.xml){\r\n            throw new Error(\"bpmnXML needs a name and a xml\");\r\n        }\r\n\r\n        self.addBpmnXML(bpmnXML.xml, bpmnXML.name);\r\n    });\r\n};\r\n\r\n/**\r\n * Initialise a new definition by loading all persisted process.\r\n * All other function that need the initialise state will wait until initialization is done.\r\n *\r\n * @param {BPMNProcessDefinition} processDefinition\r\n * @private\r\n */\r\nProcessManager.prototype._initialiseDefinition = function(processDefinition){\r\n    var self = this;\r\n\r\n    self._initializationError = null;\r\n    self._initialized = false;\r\n\r\n    self._definitionsToInitialize.push(processDefinition);\r\n\r\n    if(!self._initialising){    // if already initialising we don't call next, the definition will be initialised after current one.\r\n        next();\r\n    }\r\n\r\n    /**\r\n     * Called after all initializations are done.\r\n     * @param err\r\n     */\r\n    function execCallbacks(err){\r\n        self._definitionsToInitialize = [];\r\n\r\n        self._initializationError = err;\r\n        self._initialized = true;\r\n        self._initialising = false;\r\n\r\n        self._initialiseCallbacks.forEach(function(callback){   // call all waiting callbacks\r\n            callback(err);\r\n        });\r\n    }\r\n\r\n    function next(){\r\n        self._initialising = true;\r\n\r\n        if(self._definitionsToInitialize.length === 0){     // if all definitions have been initialized\r\n            return execCallbacks();\r\n        }\r\n\r\n        var currentDefinition = self._definitionsToInitialize.pop();    // get the next definition\r\n\r\n        if(self._processDefinitions[currentDefinition.name] ||      // if the definition already exist it means the processes were already loaded\r\n                !self._persistency){                                // if there is no persistency nothing needs to be loaded\r\n\r\n            self._processDefinitions[currentDefinition.name] = currentDefinition;   // we simply add or replace the definition\r\n            return next();\r\n        }\r\n\r\n\r\n        self._persistency.loadAll(currentDefinition.name, function(err, documents){     // load all saved document\r\n\r\n            if(err){\r\n                execCallbacks(err);\r\n                return;\r\n            }\r\n\r\n            self._processDefinitions[currentDefinition.name] = currentDefinition;\r\n\r\n            async.each(documents, function(document, done){                                                         // for each persisted document found\r\n\r\n                self._createSingleProcess(document.processId, currentDefinition.name, function(err, bpmnProcess){       // create the process\r\n                    if(err){\r\n                        return done(err);\r\n                    }\r\n\r\n                    if(self._processCache[bpmnProcess.getProcessId()]){                  // check if id already used\r\n                        return done(new Error('duplicated id in persisted data'));\r\n                    }\r\n\r\n                    self._processCache[bpmnProcess.getProcessId()] = bpmnProcess;\r\n                    done();\r\n                });\r\n\r\n            }, function(err){\r\n                if(err){\r\n                    return execCallbacks(err);\r\n                }\r\n\r\n                next();\r\n            });\r\n\r\n        });\r\n\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * The callback will be called after initialized\r\n *\r\n * @param callback\r\n * @private\r\n */\r\nProcessManager.prototype._afterInitialization = function(callback){\r\n    if(this._initialized){\r\n        return callback(this._initializationError);\r\n    }\r\n\r\n    this._initialiseCallbacks.push(callback);\r\n};\r\n\r\n/**\r\n * Change the process handler using a file.\r\n *\r\n * @param {String} name Name of the process\r\n * @param {String} handlerFilePath\r\n */\r\nProcessManager.prototype.addHandlerFilePath = function(name, handlerFilePath){\r\n    this._processHandlers[name] = handlers.getHandlerFromFile(handlerFilePath);\r\n    this._processHandlers[name].doneLoadingHandler = this._doneLoadingHandler || this._processHandlers[name].doneLoadingHandler;\r\n    this._processHandlers[name].doneSavingHandler = this._doneSavingHandler || this._processHandlers[name].doneSavingHandler;\r\n};\r\n\r\n/**\r\n * Change the process handler using a string.\r\n *\r\n * @param {String} name Name of the process\r\n * @param {String} handlerString\r\n */\r\nProcessManager.prototype.addHandlerString = function(name, handlerString){\r\n    this._processHandlers[name] = handlers.getHandlerFromString(handlerString);\r\n    this._processHandlers[name].doneLoadingHandler = this._doneLoadingHandler || this._processHandlers[name].doneLoadingHandler;\r\n    this._processHandlers[name].doneSavingHandler = this._doneSavingHandler || this._processHandlers[name].doneSavingHandler;\r\n};\r\n\r\n/**\r\n * Change the process handler using an object.\r\n *\r\n * @param {String} name Name of the process.\r\n * @param {String} handler\r\n */\r\nProcessManager.prototype.addHandler = function(name, handler){\r\n    this._processHandlers[name] = handler;\r\n    this._processHandlers[name].doneLoadingHandler = this._doneLoadingHandler || this._processHandlers[name].doneLoadingHandler;\r\n    this._processHandlers[name].doneSavingHandler = this._doneSavingHandler || this._processHandlers[name].doneSavingHandler;\r\n};\r\n\r\n/**\r\n * Add a bpmn file to the manager.\r\n * All process definition found in this file will be initialized and replace the old ones if exists.\r\n * A process handler object or file path can be passed. If none passed the same file path as the bpmn is used or the existing handler.\r\n * An error is thrown if no handler is found.\r\n *\r\n * @param {String} bpmnFilePath\r\n * @param {Object|String} processHandler\r\n */\r\nProcessManager.prototype.addBpmnFilePath = function(bpmnFilePath, processHandler){\r\n    var self = this;\r\n    var processDefinitions;\r\n\r\n    if(typeof processHandler === 'string'){\r\n        processHandler = handlers.getHandlerFromFile(processHandler);\r\n    }\r\n\r\n    if(!processHandler){\r\n        try{\r\n            processHandler = handlers.getHandlerFromFile(bpmnFilePath);\r\n            processHandler.doneLoadingHandler = self._doneLoadingHandler;\r\n            processHandler.doneSavingHandler = self._doneSavingHandler;\r\n        }catch(err){}\r\n    }\r\n\r\n    processDefinitions = definitions.getBPMNProcessDefinitions(bpmnFilePath);\r\n\r\n    processDefinitions.forEach(function(processDefinition){\r\n\r\n        if(processHandler) {\r\n            self._processHandlers[processDefinition.name] = processHandler;\r\n        } else if(!self._processHandlers[processDefinition.name]){\r\n            throw new Error('No process handler defined for process \"'+processDefinition.name+'\". The process handler must be defined before the process or with the process.');\r\n        }\r\n\r\n        self._initialiseDefinition(processDefinition);\r\n    });\r\n};\r\n\r\n/**\r\n * Add a bpmn XML to the manager.\r\n * All process definition found in this file will be initialized and replace the old ones if exists.\r\n * A process handler object or file path can be passed. If none passed the same file path as the bpmn is used or the existing handler.\r\n * An error is thrown if no handler is found.\r\n *\r\n * @param {String} bpmnXml\r\n * @param {String=} processName\r\n * @param {Object|String=} processHandler\r\n */\r\nProcessManager.prototype.addBpmnXML = function(bpmnXml, processName, processHandler){\r\n    var self = this;\r\n    var processDefinitions;\r\n\r\n    if(typeof processHandler === 'string'){\r\n        processHandler = handlers.getHandlerFromString(processHandler);\r\n    }\r\n\r\n    processDefinitions = definitions.getBPMNDefinitionsFromXML(bpmnXml, processName);\r\n\r\n    processDefinitions.forEach(function(processDefinition){\r\n\r\n        if(processHandler) {\r\n            self._processHandlers[processDefinition.name] = processHandler;\r\n        } else if(!self._processHandlers[processDefinition.name]){\r\n            throw new Error('No process handler defined for process \"'+processDefinition.name+'\". The process handler must be defined before the process or with the process.');\r\n        }\r\n\r\n        self._initialiseDefinition(processDefinition);\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * @param {String} processId\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype.get = function get(processId, callback) {\r\n    var self = this;\r\n\r\n    this._afterInitialization(function(err){\r\n        if(callback){\r\n            callback(err, self._processCache[processId]);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param {String} processId\r\n * @param {String} processName\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype._createSingleProcess = function(processId, processName, callback){\r\n    createBPMNProcess(processId, this._processDefinitions[processName], this._processHandlers[processName], this._persistency, function(err, bpmnProcess){\r\n        callback(err, bpmnProcess);\r\n    });\r\n};\r\n\r\n/**\r\n * @param {Array.<{name: String, id: String}>} processDescriptors\r\n * @param {Function} callback\r\n * @return {Array.<BPMNProcessClient>}\r\n */\r\nProcessManager.prototype._createCollaboratingProcesses = function(processDescriptors, callback) {\r\n    var self = this;\r\n    var processes = {};\r\n\r\n    async.eachSeries(processDescriptors, function(processDescriptor, done) {\r\n\r\n        self._createSingleProcess(processDescriptor.id, processDescriptor.name, function(err, bpmnProcess){\r\n            if(err){\r\n                done(err);\r\n            }\r\n            processes[processDescriptor.name] = bpmnProcess;\r\n            done();\r\n        });\r\n\r\n    }, function(err){\r\n        var results = [];\r\n\r\n        Object.keys(processes).forEach(function(name){\r\n            var bpmnProcess = processes[name];\r\n\r\n            var participants = bpmnProcess.getProcessDefinition().getCollaboratingParticipants();\r\n\r\n            participants.forEach(function (participant) {\r\n                bpmnProcess.addParticipant(participant.name, processes[participant.name]);\r\n            });\r\n\r\n            results.push(bpmnProcess);\r\n        });\r\n\r\n        callback(err, results);\r\n    });\r\n};\r\n\r\n/**\r\n * A BPMN process is created using the descriptor name and id, it's state is loaded if it has been persisted.\r\n * A simple id can be passed if there is only one process definition.\r\n * If there are multiple definitions, an array of descriptors can be passed and an array of collaborating BPMN processes is created.\r\n * The processId parameter needs to correspond.\r\n *\r\n * @param {String|{name: String, id: String}|Array.<{name: String, id: String}>} descriptors\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype.createProcess = function(descriptors, callback) {\r\n    var self = this;\r\n\r\n    this._afterInitialization(function(err){\r\n        if(err){\r\n            return callback(err);\r\n        }\r\n\r\n        if (typeof descriptors === 'string' && Object.keys(self._processDefinitions).length !== 1) {\r\n            return callback(new Error(\"The manager contains more than one process definition. \" +\r\n                \"processId have to be an Array.<{name: String, id: String}>} \"));\r\n        }\r\n\r\n        if(util.isArray(descriptors)) {\r\n            descriptors.forEach(function(descriptor){             // check if one of the ids is already used\r\n                if(self._processCache[descriptor.id]){\r\n                    err = new Error('id already used');\r\n                }\r\n            });\r\n            if(err){\r\n                return callback(err);\r\n            }\r\n\r\n            self._createCollaboratingProcesses(descriptors, function(err, bpmnProcesses){\r\n                if(err){\r\n                    return callback(err);\r\n                }\r\n\r\n                descriptors.forEach(function(descriptor){             // check if one of the ids is already used\r\n                    if(self._processCache[descriptor.id]){          // again because a process could have been created in between\r\n                        err = new Error('id already used');\r\n                    }\r\n                });\r\n                if(err){\r\n                    return callback(err);\r\n                }\r\n\r\n                callback(null, bpmnProcesses.map(function(bpmnProcess){\r\n                    self._processCache[bpmnProcess.getProcessId()] = bpmnProcess;\r\n                    return bpmnProcess.processClient;\r\n                }));\r\n            });\r\n\r\n            return;\r\n        }\r\n\r\n        if(typeof descriptors === 'string') {\r\n            descriptors = {\r\n                id: descriptors,\r\n                name: Object.keys(self._processDefinitions)[0]\r\n            };\r\n        }\r\n\r\n        if(self._processCache[descriptors.id]){                                        // check if id already used\r\n            return callback(new Error('id already used'));\r\n        }\r\n\r\n        self._createSingleProcess(descriptors.id, descriptors.name, function(err, bpmnProcess){\r\n            if(err){\r\n                return callback(err);\r\n            }\r\n\r\n            if(self._processCache[descriptors.id]){                                      // check if id already used\r\n                return callback(new Error('id already used'));                      // again because a process could have been created in between\r\n            }\r\n\r\n            self._processCache[descriptors.id] = bpmnProcess;\r\n            callback(null, bpmnProcess.processClient);\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype._getAllProcesses = function(callback) {\r\n    var self = this;\r\n    var allProcessIds = Object.keys(this._processCache);\r\n\r\n    if(!callback){\r\n        return;\r\n    }\r\n\r\n    callback(null, allProcessIds.map(function(loadedProcessId) {\r\n        return self._processCache[loadedProcessId];\r\n    }));\r\n};\r\n\r\n/**\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype.getAllProcesses = function(callback) {\r\n    var self = this;\r\n\r\n    if(!callback){\r\n        return;\r\n    }\r\n\r\n\r\n    this._afterInitialization(function(err){\r\n        if (err) {\r\n            return callback(err);\r\n        }\r\n\r\n        self._getAllProcesses(function (err, bpmnProcesses) {\r\n            if (err) {\r\n                return callback(err);\r\n            }\r\n\r\n            callback(null, bpmnProcesses.map(function (bpmnProcess) {\r\n                return bpmnProcess.processClient;\r\n            }));\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * Returns all processes where the current task, activity, or event name equals the given state name\r\n * @param {String} stateName.\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype.findByState = function(stateName, callback) {\r\n    var self = this;\r\n\r\n    if(!callback){\r\n        return;\r\n    }\r\n\r\n    this._afterInitialization(function(err){\r\n        if (err) {\r\n            return callback(err);\r\n        }\r\n\r\n        self.getAllProcesses(function (err, bpmnProcesses) {\r\n            if (err) {\r\n                return callback(err);\r\n            }\r\n\r\n            callback(null, find.findByState(bpmnProcesses, stateName));\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * @param {Object} query The query is an object that is being matched to the data.\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype.findByProperty = function(query, callback) {\r\n    var self = this;\r\n\r\n    if(!callback){\r\n        return;\r\n    }\r\n\r\n    this._afterInitialization(function(err){\r\n        if (err) {\r\n            return callback(err);\r\n        }\r\n\r\n        self.getAllProcesses(function (err, bpmnProcesses) {\r\n            if (err) {\r\n                return callback(err);\r\n            }\r\n\r\n            callback(null, find.findByProperty(bpmnProcesses, query));\r\n        });\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * @param {String} processName\r\n * @param {Boolean=} caseSensitive\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype.findByName = function(processName, caseSensitive, callback) {\r\n    var self = this;\r\n\r\n    if(typeof caseSensitive === 'function'){\r\n        callback = caseSensitive;\r\n        caseSensitive = true;\r\n    }\r\n\r\n    if(!callback){\r\n        return;\r\n    }\r\n\r\n    this._afterInitialization(function(err){\r\n        if (err) {\r\n            return callback(err);\r\n        }\r\n\r\n        self.getAllProcesses(function (err, bpmnProcesses) {\r\n            if (err) {\r\n                return callback(err);\r\n            }\r\n\r\n            callback(null, find.findByName(bpmnProcesses, processName, caseSensitive));\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n *\r\n * @param {Function} callback\r\n */\r\nProcessManager.prototype.getDefinitionNames = function(callback){\r\n    var self = this;\r\n\r\n    this._afterInitialization(function(err){\r\n        callback(err, Object.keys(self._processDefinitions));\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * Creates a REST server based on the restify framework. It takes two parameters, options and restifyOptions.\r\n *      options: optional object having the following optional properties\r\n *          createProcessId: Function that returns a UUID. Default: node-uuid.v1()\r\n *          logLevel: used log level. Default: Error. Use logger.logLevels to set.\r\n *      restifyOptions: these options are given to the restify.createServer call.\r\n *                      If not given, the log property is set to the internal winston logger and\r\n *                      the name property is set to 'bpmnRESTServer'\r\n * @param {{createProcessId: function, logLevel: logger.logLevels}=} options\r\n * @param {Object=} restifyOptions\r\n * @returns {*}\r\n */\r\nProcessManager.prototype.createServer = function(options, restifyOptions){\r\n    return rest.createServer(this,  options, restifyOptions);\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/persistency/persistency.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar FilePersistency = require('./file.js').Persistency;\r\nvar MongoDBPersistency = require('./mongodb.js').Persistency;\r\n\r\n/**\r\n * @param {{uri: String, uri: String}} options\r\n * @constructor\r\n */\r\nvar Persistency = exports.Persistency = function(options) {\r\n    var isMongoDbUri;\r\n    var uri = options ? options.uri : null;\r\n\r\n    if (uri) {\r\n       isMongoDbUri = uri.indexOf('mongodb://') === 0;\r\n       if (isMongoDbUri) {\r\n           this.implementation = new MongoDBPersistency(uri, options);\r\n       } else {\r\n           this.implementation = new FilePersistency(uri);\r\n       }\r\n    } else {\r\n        throw new Error(\"Persistency options must contain an uri property.\");\r\n    }\r\n};\r\n\r\n/**\r\n * @param {{processInstanceId: String}} persistentData\r\n * @param {Function} done\r\n */\r\nPersistency.prototype.persist = function(persistentData, done) {\r\n    this.implementation.persist(persistentData, done);\r\n};\r\n\r\n/**\r\n * @param {String} processId\r\n * @param {String} processName\r\n * @param done\r\n */\r\nPersistency.prototype.load = function(processId, processName, done) {\r\n    this.implementation.load(processId, processName, done);\r\n};\r\n\r\n/**\r\n * @param {String} processName\r\n * @param done\r\n */\r\nPersistency.prototype.loadAll = function(processName, done) {\r\n    this.implementation.loadAll(processName, done);\r\n};\r\n\r\n/**\r\n * @param done\r\n */\r\nPersistency.prototype.close = function(done) {\r\n    this.implementation.close(done);\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/persistency/file.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar JaguarDb = require('jaguardb').JaguarDb;\r\n\r\n/**\r\n * @param {String} path Path to directory containing the files\r\n * @constructor\r\n */\r\nvar Persistency = exports.Persistency = function(path) {\r\n    this.path = path;\r\n    this.db = new JaguarDb();\r\n};\r\n\r\n/**\r\n * @param {{processInstanceId: String}} persistentData\r\n * @param {Function} done\r\n */\r\nPersistency.prototype.persist = function(persistentData, done) {\r\n    var db = this.db;\r\n    var processId = persistentData.processId;\r\n    var query = {processId: processId};\r\n    var fields = {}; // all fields\r\n\r\n    db.connect(this.path, function(error) {\r\n        if(error) {\r\n            done(error);\r\n        } else {\r\n            db.find(query, fields, function(err, documents) {\r\n                if (documents && documents.length > 0) {\r\n                    if (documents.length === 1) {\r\n                        persistentData._id = documents[0]._id;\r\n                        persistentData._saved = documents[0]._saved;\r\n                        persistentData._updated = Date.now();\r\n                        db.update(persistentData, function(error, updatedData) {\r\n                            if(error) {\r\n                                done(error);\r\n                            } else {\r\n                                done(null, updatedData);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        done(new Error(\"Process ID: '\" + processId + \"' is not unique in the DB\"));\r\n                    }\r\n                } else {\r\n                    persistentData._saved = Date.now();\r\n                    persistentData._updated = persistentData._saved;\r\n                    db.insert(persistentData, function(error, insertedData) {\r\n                        if(error) {\r\n                            done(error);\r\n                        } else {\r\n                            done(null, insertedData);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param {String} processId\r\n * @param {String} processName\r\n * @param done\r\n */\r\nPersistency.prototype.load = function(processId, processName, done) {\r\n    var db = this.db;\r\n    var query = {processId: processId, processName: processName};\r\n    var fields = {}; // all fields\r\n\r\n    db.connect(this.path, function(error) {\r\n        if(error) {\r\n            done(error);\r\n        } else {\r\n            db.find(query, fields, function(err, documents) {\r\n                if (documents && documents.length > 0) {\r\n                    if (documents.length === 1) {\r\n                        if(error) {\r\n                            done(error);\r\n                        } else {\r\n                            done(null, documents[0]);\r\n                        }\r\n                    } else {\r\n                        done(new Error(\"Persistency: Process ID: '\" + processId + \"' is not unique in the DB\"));\r\n                    }\r\n                } else {\r\n                    // we allow that nothing has been found because this happens\r\n                    // the very first time when the process is being created\r\n                    done();\r\n                }\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param {String} processName\r\n * @param done\r\n */\r\nPersistency.prototype.loadAll = function(processName, done) {\r\n    var db = this.db;\r\n    var query = {processName: processName};\r\n    var fields = {}; // all fields\r\n\r\n    db.connect(this.path, function(error) {\r\n        if(error) {\r\n            done(error);\r\n        } else {\r\n            db.find(query, fields, function(err, documents) {\r\n                if(err){\r\n                    return done(err);\r\n                }\r\n\r\n                if (documents) {\r\n                    done(null, documents);\r\n                } else {\r\n                    done(null, []);\r\n                }\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nPersistency.prototype.close = function() {};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/persistency/mongodb.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar MongoClient = require('mongodb').MongoClient;\r\nvar EventEmitter = require('events').EventEmitter;\r\n\r\n// details see http://mongodb.github.io/node-mongodb-native/driver-articles/mongoclient.html\r\nvar defaultOptions = {\r\n    \"server\": {\r\n        // if we set this to true, we will try to reconnect even if the url is wrong.\r\n        // So we can never close the connection if something went wrong\r\n        // If this were true, the connectionNOK test will fail.\r\n        \"auto_reconnect\": false,\r\n        \"poolSize\": 10,\r\n        \"socketOptions\": {\r\n            \"connectTimeoutMS\": 5000\r\n        }\r\n    }\r\n};\r\n\r\n/*\r\n * We have one global connection.\r\n * We follow the advice of the inventor of the MongoClient:\r\n *   \"You open do MongoClient.connect once when your app boots up and reuse the db object. It's not a singleton connection pool each .connect creates a new connection pool. So open it once an reuse across all requests.\"\r\n *   Source: https://groups.google.com/forum/#!msg/node-mongodb-native/mSGnnuG8C1o/Hiaqvdu1bWoJ\r\n */\r\nvar uniqueDbConnections = {};\r\nvar waitingForConnectionEventEmitters = {};\r\nvar connectionEventName = 'connectionEventName';\r\n\r\n/**\r\n * @param {String} uri\r\n * @param {*} options\r\n * @constructor\r\n */\r\nvar Persistency = exports.Persistency = function(uri, options) {\r\n    this.options = options || defaultOptions;\r\n    this.options.server = this.options.server || defaultOptions.server;\r\n\r\n    if (this.options.logger) {\r\n        this._trace = this.options.logger.trace || function() {};\r\n    } else {\r\n        this._trace = function() {};\r\n    }\r\n\r\n    if (uri) {\r\n        this.uri = uri;\r\n    } else {\r\n        throw new Error(\"MongoDB: Persistency: requires uri to db\");\r\n    }\r\n};\r\n\r\n/**\r\n * @param {{processInstanceId: String}} persistentData\r\n * @param {Function} done\r\n */\r\nPersistency.prototype.persist = function(persistentData, done) {\r\n  this._execute(this._findAndModify, persistentData, done);\r\n};\r\n\r\n/**\r\n * @param {String} processId\r\n * @param {String} processName\r\n * @param done\r\n */\r\nPersistency.prototype.load = function(processId, processName, done) {\r\n    this._execute(this._find, {processId: processId, processName: processName}, done);\r\n};\r\n\r\n/**\r\n * @param {String} processName\r\n * @param done\r\n */\r\nPersistency.prototype.loadAll = function(processName, done) {\r\n    this._execute(this._findAll, processName, done);\r\n};\r\n\r\n/**\r\n * @param done\r\n */\r\nPersistency.prototype.close = function(done) {\r\n    var self = this;\r\n    var connection = self._getConnection();\r\n\r\n    if (connection) {\r\n        connection.close(true, function(error) {\r\n            self._resetConnection();\r\n            done(error);\r\n        });\r\n    } else {\r\n        done();\r\n    }\r\n};\r\n\r\n/**\r\n * @param {Function} dbCall\r\n * @param {*} argument\r\n * @param {Function} done\r\n */\r\nPersistency.prototype._execute = function(dbCall, argument, done) {\r\n    var waitingForConnection;\r\n    var self = this;\r\n    var connection = self._getConnection();\r\n\r\n    if (connection) {\r\n        self._trace(\"\\nUsing existing connection '\" + connection.databaseName + \"'\");\r\n        dbCall.call(self, connection, argument, done);\r\n    } else {\r\n        waitingForConnection = self._waitingForConnection();\r\n        if (waitingForConnection) {\r\n            self._trace(\"Waiting for connection. URI: \" + self.uri);\r\n            waitingForConnection.on(connectionEventName, function(error, db) {\r\n                if (error) {\r\n                    self._resetConnection();\r\n                    self._trace(\"ERROR: Stopped waiting for connection. URI: \" + self.uri + \" Error: \" + error);\r\n                    done(error);\r\n                } else {\r\n                    self._trace(\"Stopped waiting. Got connection '\" + db.databaseName + \"'.\");\r\n                    dbCall.call(self, db, argument, done);\r\n                }\r\n             });\r\n        } else {\r\n            self._setWaitingForConnection();\r\n            self._trace(\"Trying to get connection for URI: \" + self.uri + \" ...\");\r\n            self._connect(function(error, db) {\r\n                var waitingForConnection = self._waitingForConnection();\r\n\r\n                if(error) {\r\n                    self._trace(\"ERROR: Could not get connection. URI: \" + self.uri + \" Error: \" + error);\r\n                    waitingForConnection.emit(connectionEventName, error); // we do this to stop waiting\r\n                    self._resetConnection();\r\n                    if (db){\r\n                        db.close(function() {\r\n                            done(error);\r\n                        });\r\n                    } else {\r\n                        done(error);\r\n                    }\r\n                } else {\r\n                    self._trace(\"Got connection '\" + db.databaseName + \"' URI: \" + self.uri);\r\n                    self._setConnection(db);\r\n                    waitingForConnection.emit(connectionEventName, null, db);\r\n                    dbCall.call(self, db, argument, done);\r\n                }\r\n            });\r\n        }\r\n     }\r\n };\r\n\r\nPersistency.prototype._connect = function(done) {\r\n    MongoClient.connect(this.uri, this.options, done);\r\n};\r\n\r\n/**\r\n * @returns {*}\r\n * @private\r\n */\r\nPersistency.prototype._getConnection = function() {\r\n    return uniqueDbConnections[this.uri];\r\n};\r\n\r\n/**\r\n * @param {*} connection\r\n * @private\r\n */\r\nPersistency.prototype._setConnection = function(connection) {\r\n    uniqueDbConnections[this.uri] = connection;\r\n};\r\n\r\n/**\r\n * @returns {EventEmitter}\r\n * @private\r\n */\r\nPersistency.prototype._waitingForConnection = function() {\r\n    return waitingForConnectionEventEmitters[this.uri];\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPersistency.prototype._setWaitingForConnection = function() {\r\n    waitingForConnectionEventEmitters[this.uri] = new EventEmitter();\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPersistency.prototype._resetConnection = function() {\r\n    delete uniqueDbConnections[this.uri];\r\n    delete waitingForConnectionEventEmitters[this.uri];\r\n};\r\n\r\n/**\r\n * @param db\r\n * @param query\r\n * @param done\r\n * @private\r\n */\r\nPersistency.prototype._find = function(db, query, done) {\r\n    var self = this;\r\n    var processId = query.processId;\r\n    var processName = query.processName;\r\n    var collection = db.collection(processName);\r\n\r\n    self._trace(\"Start finding '\" + processName + \"' ('\" + processId + \"').\");\r\n\r\n    collection.find({processId: processId})\r\n        .limit(2) // just 2 to find out weather we really found more than one document (see error below)\r\n        .toArray(function(error, documents) {\r\n            var size, errorMessage;\r\n\r\n            if(error) {\r\n                self._trace(\"Couldn't find '\" + processName + \"' ('\" + processId + \"'). Error: '\" + error + \"'.\");\r\n                done(error);\r\n            } else {\r\n                size = documents.length;\r\n                if (size === 0) {\r\n                    self._trace(\"Didn't find '\" + processName + \"' ('\" + processId + \"').\");\r\n                    done();\r\n                } else if (size === 1) {\r\n                    self._trace(\"Found '\" + processName + \"' ('\" + processId + \"').\");\r\n                    done(null, documents[0]);\r\n                } else {\r\n                    errorMessage = \"Found more than one process of \" + processName + \"' ('\" + processId + \"').\";\r\n                    self._trace(\"ERROR '\" + errorMessage + \"'\");\r\n                    done(new Error(errorMessage));\r\n                }\r\n            }\r\n        }\r\n    );\r\n};\r\n\r\n/**\r\n * @param db\r\n * @param processName\r\n * @param done\r\n * @private\r\n */\r\nPersistency.prototype._findAll = function(db, processName, done) {\r\n    var self = this;\r\n    var collection = db.collection(processName);\r\n\r\n    self._trace(\"Start finding '\" + processName + \".\");\r\n\r\n    collection.find({})\r\n        .toArray(function(error, documents) {\r\n\r\n            if(error) {\r\n                self._trace(\"Couldn't find '\" + processName + \". Error: '\" + error + \"'.\");\r\n                done(error);\r\n            } else {\r\n                done(null, documents);\r\n            }\r\n        }\r\n    );\r\n};\r\n\r\n/**\r\n * @param db\r\n * @param persistentData\r\n * @param done\r\n * @private\r\n */\r\nPersistency.prototype._findAndModify = function(db, persistentData, done) {\r\n    var self = this;\r\n    var processId = persistentData.processId;\r\n    var processName = persistentData.processName;\r\n    var collection = db.collection(processName);\r\n\r\n    self._trace(\"Start persisting '\" + processName + \"'\");\r\n\r\n    collection.findAndModify(\r\n        {processId: processId},\r\n        [['_id','desc']], // if processId is not unique we take the latest one\r\n        persistentData,\r\n        {\"upsert\": true, \"new\": true}, // upsert: if not yet persisted insert data, otherwise update; new: return updated document\r\n        function(error, document) {\r\n            if(error) {\r\n                self._trace(\"Couldn't persist '\" + processName + \"' ('\" + processId + \"'). Error: '\" + error + \"'.\");\r\n                done(error);\r\n            } else {\r\n                persistentData._id = document._id;\r\n                self._trace(\"Persisted '\" + processName + \"' ('\" + processId + \"').\");\r\n                done(null, document);\r\n            }\r\n        }\r\n    );\r\n};\r\n\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/find.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * @param {Object} query The query is an object that is being matched to the data.\r\n * @param {Array.<BPMNProcess | BPMNProcessClient>} bpmnProcesses List of processes the query is applied to. Default: all loaded processes.\r\n * @returns {Array.<BPMNProcessClient>}\r\n */\r\nexports.findByProperty = function(bpmnProcesses, query) {\r\n    var foundProcesses = [];\r\n    var findAll = !query;\r\n\r\n    bpmnProcesses.forEach(function(bpmnProcess) {\r\n        if (findAll || hasMatchingProperties(bpmnProcess.getProperties(), query)) {\r\n            foundProcesses.push(bpmnProcess.processClient || bpmnProcess);\r\n        }\r\n    });\r\n    return foundProcesses;\r\n};\r\n\r\n/**\r\n * @param {Object} processData\r\n * @param {Object} query\r\n * @returns {Boolean}\r\n */\r\nvar hasMatchingProperties = function(processData, query) {\r\n    var isMatching = true;\r\n    var queryFields = query ? Object.getOwnPropertyNames(query) : [];\r\n\r\n    queryFields.forEach(function (queryField){\r\n        if (isMatching) {  // AND semantics: if it is false once, it stays false\r\n            isMatching = hasMatchingProperty(processData, queryField, query[queryField]);\r\n        }\r\n     });\r\n    return isMatching;\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object} processData\r\n * @param {String} propertyName\r\n * @param {String|Number|Boolean|Date} queryValue\r\n * @returns {Boolean}\r\n */\r\nvar hasMatchingProperty = function(processData, propertyName, queryValue) {\r\n    var isMatching = false;\r\n    if (processData) {\r\n        var separatorIndex = propertyName ? propertyName.indexOf('.') : -1;\r\n        if (separatorIndex > -1) {\r\n            var parent = propertyName.substring(0, separatorIndex);\r\n            var rest = propertyName.substring(separatorIndex + 1);\r\n            isMatching = hasMatchingProperty(processData[parent], rest, queryValue);\r\n        } else {\r\n            if(processData.hasOwnProperty(propertyName)) {\r\n                if (processData[propertyName] === queryValue) {\r\n                    isMatching = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return isMatching;\r\n};\r\n\r\n/**\r\n * Returns all processes where the current task, activity, or event name equals the given state name\r\n * @param {String} stateName.\r\n * @param {Array.<BPMNProcess | BPMNProcessClient>} bpmnProcesses List of processes the query is applied to. Default: all loaded processes.\r\n * @returns {Array.<BPMNProcessClient>}\r\n */\r\nexports.findByState = function(bpmnProcesses, stateName) {\r\n    var foundProcesses = [];\r\n    var findAll = !stateName;\r\n\r\n    bpmnProcesses.forEach(function(bpmnProcess) {\r\n        if (findAll || bpmnProcess.getState().hasTokens(stateName)) {\r\n            foundProcesses.push(bpmnProcess.processClient || bpmnProcess);\r\n        }\r\n    });\r\n    return foundProcesses;\r\n};\r\n\r\n/**\r\n * @param {String} processName.\r\n * @param {Boolean=} caseSensitive\r\n * @param {Array.<BPMNProcess | BPMNProcessClient>} bpmnProcesses List of processes the query is applied to. Default: all loaded processes.\r\n * @returns {Array.<BPMNProcessClient>}\r\n */\r\nexports.findByName  = function(bpmnProcesses, processName, caseSensitive) {\r\n    var foundProcesses = [];\r\n\r\n    if (processName) {\r\n        var compare = function(a, b) {\r\n            var result;\r\n            if (caseSensitive === undefined || caseSensitive) {\r\n                result = (a === b);\r\n            } else {\r\n                result = (a.toLowerCase() === b.toLowerCase());\r\n            }\r\n            return result;\r\n        };\r\n\r\n        bpmnProcesses.forEach(function(bpmnProcess) {\r\n            var name = bpmnProcess.getProcessDefinition().name;\r\n            if (compare(name, processName)) {\r\n                foundProcesses.push(bpmnProcess.processClient || bpmnProcess);\r\n            }\r\n        });\r\n    }\r\n    return foundProcesses;\r\n};","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/rest.js":"/**\r\n * Copyright: E2E Technologies Ltd\r\n */\r\n\"use strict\";\r\n\r\nvar find = require('./find');\r\nvar log = require('./logger');\r\nvar restify = require('restify');\r\nvar uuid = require('node-uuid');\r\nvar querystring = require('querystring');\r\n//var bunyan2winston = require(\"./utils/bunyan2winston\");\r\n\r\n\r\nvar transactionLog = null;\r\ntry {\r\n    transactionLog = require('e2e-transaction-logger');\r\n}catch(err){\r\n    transactionLog = null;\r\n}\r\n\r\nvar receivedMessageIds = {};\r\n\r\nexports.clearReceivedMessageIds = function() {\r\n    receivedMessageIds = {};\r\n};\r\n\r\nvar reservedQueryNames = {\r\n    \"state\": \"state\"\r\n};\r\n\r\n\r\n/**\r\n * @api {post} /bpmnCollaborate Create and start process\r\n * @apiName CreateAndStartCollaborating\r\n * @apiGroup BPMN\r\n *\r\n * @apiDescription Creates collaborating processes and then triggers immediately the start event of main process.\r\n *\r\n * @req.body {array} of processName Name,id of the process as used in the BPMN model\r\n * {name: \"processOneName\", \"processOneId\"},\r\n * {name: \"processTwoName\", processTwoId},\r\n * {name: \"processThreeName\", processThreeId},\r\n * {name: \"mainProcess\", mainProcessId, startEventName:\"starterEventName\"}\r\n * gotta fix routes, first one traps all.\r\n\r\n */\r\n var createAndStartCollaboratingProcessRoute = '/bpmnCollaborate';\r\n\r\n\r\n\r\n/**\r\n * @api {post} /:processName Create process\r\n * @apiName CreateProcess\r\n * @apiGroup BPMN\r\n *\r\n * @apiDescription Creates a process but does not start it. To do this either send a message\r\n *                  or use CreateAndStartProcess.\r\n *\r\n * @apiDescription {String} processName Name of the process as used in the BPMN model\r\n */\r\nvar createProcessRoute = '/:processName';\r\n\r\n/**\r\n * @api {post} /:processName/:startEventName Create and start process\r\n * @apiName CreateAndStartProcess\r\n * @apiGroup BPMN\r\n *\r\n * @apiDescription Creates a process and then triggers immediately the start event.\r\n *\r\n * @apiParam {String} processName Name of the process as used in the BPMN model\r\n * @apiParam {String} startEventName Event name as used in the BPMN model for starting this process\r\n */\r\nvar createAndStartProcessRoute = '/:processName/:startEventName';\r\n\r\n/**\r\n * @api {get} /:processName/:id Get process instance\r\n * @apiName GetProcess\r\n * @apiGroup BPMN\r\n *\r\n * @apiDescription Returns the process state.\r\n *\r\n * @apiParam {String} processName Name of the process as used in the BPMN model\r\n * @apiParam {String} id Unique id of the process instance\r\n */\r\nvar getProcessRoute = '/:processName/:id';\r\n\r\n/**\r\n * @api {get} /:processName/[?query]    Get process instances\r\n * @apiName GetProcesses\r\n * @apiGroup BPMN\r\n *\r\n * @apiDescription Get process instances.\r\n *                 The query strings accesses process properties.\r\n *\r\n * @apiParam {String} processName Name of the process as used in the BPMN model\r\n */\r\nvar getProcessesRoute = '/:processName';\r\n\r\n/**\r\n * @api {put} /:processName/:id/:messageName/:messageId Send messages or trigger events.\r\n *\r\n * @apiName SendMessage\r\n * @apiGroup BPMN\r\n *\r\n * @apiDescription The messageId is used to make this call idempotent.\r\n *                 If the messageId is received the first time, a message is being created and\r\n *                 sent to the process and the status code 201 (Created) is returned.\r\n *                 For all subsequent request having the same URI the message is thrown away and\r\n *                 the status code 200 is returned.\r\n *\r\n * @apiParam {String} processName Name of the process as used in the BPMN model\r\n * @apiParam {String} id Unique id of the process instance\r\n * @apiParam {String} messageName Message or event name as used in the BPMN model for messages respectively event elements\r\n * @apiParam {String} messageId This id is used to implement idempotency.\r\n *\r\n */\r\nvar sendMessageRoute = '/:processName/:id/:messageName/:messageId';\r\n\r\n/**\r\n * Creates a REST server based on the restify framework. It takes two parameters, options and restifyOptions.\r\n *      options: optional object having the following optional properties\r\n *          createProcessId: Function that returns a UUID. Default: node-uuid.v1()\r\n *          logLevel: used log level. Default: Error. Use logger.logLevels to set.\r\n *      restifyOptions: these options are given to the restify.createServer call.\r\n *                      If not given, the log property is set to the internal winston logger and\r\n *                      the name property is set to 'bpmnRESTServer'\r\n * @param {ProcessManager} manager\r\n * @param {{createProcessId: function, logLevel: logger.logLevels}=} options\r\n * @param {Object=} restifyOptions\r\n * @returns {*}\r\n */\r\nexports.createServer = function(manager, options, restifyOptions) {\r\n    var logger, serverOptions, server;\r\n    var settings = options || {};\r\n\r\n    settings.createProcessId = settings.createProcessId || uuid.v1;\r\n\r\n    logger = new log.Logger(null, settings);\r\n    serverOptions = restifyOptions || {};\r\n    serverOptions.name = serverOptions.name || \"BPMNProcessServer\";\r\n\r\n    // Shimming the log doesn't work as expected: I cannot switch it off for example.\r\n    // Additionally, the log format is horrible. So for the time being we use our own logging\r\n    // serverOptions.log = serverOptions.log || bunyan2winston.createLogger(logger.winstonLogger);\r\n\r\n    server = restify.createServer(serverOptions);\r\n\r\n    server.use(restify.queryParser({ mapParams: false }));\r\n    server.use(restify.bodyParser({ mapParams: false }));\r\n    server.on('after', function( request, response, route, error) {\r\n        var handler = options.onServerAfterEvent || onServerAfterEvent;\r\n        handler(logger, request, response, route, error);\r\n    });\r\n\r\n    server.get(getProcessRoute,\r\n        transactionLog.transactionLoggerMiddleware({\r\n                name: function(req){\r\n                    return 'GET ' + req.params.processName + ' process';\r\n                }\r\n            }),\r\n        function(req, res, next){\r\n            getProcess(manager, req, res, next);\r\n        });\r\n    server.get(getProcessesRoute,\r\n        transactionLog.transactionLoggerMiddleware({\r\n            name: function(req){\r\n                return 'GET ' + req.params.processName + ' processes';\r\n            }\r\n        }),\r\n        function(req, res, next){\r\n            getProcesses(manager, req, res, next);\r\n        });\r\n    server.put(sendMessageRoute,\r\n        transactionLog.transactionLoggerMiddleware({\r\n            name: function(req){\r\n                return 'PUT ' + req.params.messageName + ' message to ' + req.params.processName + ' process';\r\n            }\r\n        }),\r\n        function(req, res, next) {\r\n            sendMessage(manager, logger, req, res, next);\r\n        }\r\n    );\r\n\r\n    // TODO: we need to change these routes.  the catch all '/' makes this load order dependent.\r\n    server.post(createAndStartCollaboratingProcessRoute,\r\n      transactionLog.transactionLoggerMiddleware({\r\n        name: function(req) {\r\n          return 'POST create and start collaborating processes';\r\n        }\r\n      }),\r\n      function(req, res, next) {\r\n        createAndStartCollaboratingProcess(manager, settings, logger, req, res, next);\r\n      }\r\n    );\r\n\r\n    server.post(createProcessRoute,\r\n        transactionLog.transactionLoggerMiddleware({\r\n            name: function(req){\r\n                return 'POST create ' + req.params.processName + ' process';\r\n            }\r\n        }),\r\n        function(req, res, next) {\r\n            createProcess(manager, settings, logger, req, res, next);\r\n}\r\n    );\r\n    server.post(createAndStartProcessRoute,\r\n        transactionLog.transactionLoggerMiddleware({\r\n            name: function(req){\r\n                return 'POST create and start ' + req.params.processName + ' process';\r\n            }\r\n        }),\r\n        function(req, res, next) {\r\n            createAndStartProcess(manager, settings, logger, req, res, next);\r\n        }\r\n    );\r\n\r\n    return server;\r\n};\r\n\r\nfunction createProcess(manager, settings, logger, req, res, next) {\r\n    createAndStartProcess(manager, settings, logger, req, res, next, false);\r\n}\r\n\r\nfunction createAndStartProcess(manager, options, logger, req, res, next, startProcess) {\r\n    var processId, processNameWithoutCase, startEventName;\r\n\r\n    processId = options.createProcessId();\r\n    processNameWithoutCase = querystring.unescape(req.params.processName);\r\n\r\n    getNameWithCase(manager, processNameWithoutCase, function(err, processName){\r\n        if(err){\r\n            return sendError(err, next);\r\n        }\r\n\r\n        if(!processName){\r\n            return next(new restify.InvalidArgumentError(\"Could not find process name '\" + processNameWithoutCase + \"'.\"));\r\n        }\r\n\r\n        manager.createProcess({id: processId, name: processName}, function(err, bpmnProcess){\r\n            if(err){\r\n                return sendError(err, next);\r\n            }\r\n\r\n            logger.setProcess(bpmnProcess);\r\n\r\n            if (startProcess === undefined || startProcess) {\r\n                startEventName = querystring.unescape(req.params.startEventName);\r\n\r\n                try{\r\n                    triggerEvent(bpmnProcess, logger, startEventName, req.body, true);\r\n                } catch (e) {\r\n                    return sendError(e, next);\r\n                }\r\n            }\r\n\r\n            res.send(201, getProcessResponse(bpmnProcess));\r\n        });\r\n    });\r\n\r\n}\r\n\r\nfunction createAndStartCollaboratingProcess(manager, options, logger, req, res, next) {\r\n  var processId, startEventName, processDescriptors, mainProcessDescriptor, bpmnMainProcess, numDescriptors;\r\n\r\n  processId = options.createProcessId();\r\n  processDescriptors = req.body.processDescriptors;\r\n  numDescriptors = processDescriptors.length;\r\n  processDescriptors.forEach(function(processDescriptor,i) {\r\n\r\n    var processNameWithoutCase = processDescriptor.name;\r\n    getNameWithCase(manager, processNameWithoutCase, function(err, processName) {\r\n      if (err) {\r\n        return sendError(err, next);\r\n      }\r\n\r\n      if (!processName) {\r\n        return next(new restify.InvalidArgumentError(\"Could not find process name '\" + processNameWithoutCase + \"'.\"));\r\n      }\r\n\r\n    });\r\n    if (processDescriptor.startEventName) {\r\n      mainProcessDescriptor = processDescriptor;\r\n    }\r\n\r\n    //last loop\r\n    if (i == numDescriptors - 1){\r\n      manager.createProcess(\r\n        processDescriptors,\r\n        function(err, bpmnProcesses) {\r\n          if (err) {\r\n            return sendError(err, next);\r\n          }\r\n\r\n          bpmnProcesses.forEach(function(bpmnProcess) {\r\n            logger.setProcess(bpmnProcess);\r\n            if (mainProcessDescriptor.id === bpmnProcess.getProcessId()) {\r\n              startEventName = mainProcessDescriptor.startEventName;\r\n\r\n              try {\r\n                triggerEvent(bpmnProcess, logger, startEventName, req.body, true);\r\n                bpmnMainProcess = bpmnProcess;\r\n              } catch (e) {\r\n                return sendError(e, next);\r\n              }\r\n            }\r\n\r\n          });\r\n\r\n          res.send(201, getProcessResponse(bpmnMainProcess));\r\n        });\r\n    }\r\n\r\n  });\r\n\r\n}\r\n\r\n\r\n\r\nfunction getProcess(manager, req, res, next) {\r\n    var processId = getParameter(req, \"id\");\r\n\r\n    manager.get(processId, function(err, bpmnProcess){\r\n        if(err){\r\n            return sendError(err, next);\r\n        }\r\n\r\n        res.send(getProcessResponse(bpmnProcess));\r\n    });\r\n}\r\n\r\n// TODO: paging?\r\nfunction getProcesses(manager, req, res, next) {\r\n    var stateName, processName, response;\r\n\r\n    processName = querystring.unescape(req.params.processName);\r\n\r\n    manager.findByName(processName, false, function(err, bpmnProcesses){\r\n        if(err){\r\n            return sendError(err, next);\r\n        }\r\n\r\n        if (req.query) {\r\n            bpmnProcesses = find.findByProperty(bpmnProcesses, getPropertyQuery(req.query));\r\n\r\n            stateName = req.query[reservedQueryNames.state];\r\n            if (stateName) {\r\n                bpmnProcesses = find.findByState(bpmnProcesses, stateName);\r\n            }\r\n        }\r\n\r\n        response = bpmnProcesses.map(function(bpmnProcess) {\r\n            return getProcessResponse(bpmnProcess);\r\n        });\r\n\r\n        res.send(response);\r\n    });\r\n}\r\n\r\nfunction sendMessage(manager, logger, req, res, next) {\r\n\r\n    var processId = getParameter(req, \"id\");\r\n    var processName = getParameter(req, \"processName\");\r\n    var messageId = getParameter(req, \"messageId\");\r\n    var messageName = getParameter(req, \"messageName\");\r\n\r\n    manager.get(processId, function(err, bpmnProcess){\r\n        if(err){\r\n            return sendError(err, next);\r\n        }\r\n\r\n        var idempotenceId = processName + '.' + processId + '.' + messageName + '.' + messageId;\r\n\r\n        logger.setProcess(bpmnProcess);\r\n\r\n        if (hasBeenAlreadyReceived(idempotenceId)) {\r\n            return res.send(200, getProcessResponse(bpmnProcess));\r\n        }\r\n\r\n        try {\r\n            triggerEvent(bpmnProcess, logger, messageName, req.body);\r\n            // 201: Resource (=message) created\r\n            res.send(201, getProcessResponse(bpmnProcess));\r\n        } catch (e) {\r\n            sendError(e, next);\r\n        }\r\n\r\n    });\r\n\r\n}\r\n\r\nfunction getParameter(req, parameterName) {\r\n    return (querystring.unescape(req.params[parameterName]));\r\n}\r\n\r\n/**\r\n * @param {BPMNProcess} bpmnProcess\r\n * @returns {{state: *}}\r\n */\r\nfunction getProcessResponse(bpmnProcess) {\r\n    var response = {}, processId, processName, escape;\r\n\r\n    if (bpmnProcess) {\r\n\r\n        processId = bpmnProcess.getProcessId();\r\n        processName = bpmnProcess.getProcessDefinition().name;\r\n        escape = querystring.escape;\r\n\r\n        response = {\r\n            id: processId,\r\n            name: processName,\r\n            link: {\r\n                \"rel\": \"self\",\r\n                \"href\": \"/\" + escape(processName) + \"/\" + escape(processId)\r\n            },\r\n            state: bpmnProcess.getState().tokens,\r\n            history: bpmnProcess.getHistory().historyEntries,\r\n            properties: bpmnProcess.getProperties()\r\n        };\r\n\r\n    }\r\n\r\n    return response;\r\n}\r\n\r\nfunction getPropertyQuery(query) {\r\n    var propertyQuery = {};\r\n    var queryNames = Object.keys(query);\r\n\r\n    queryNames.forEach(function(queryName) {\r\n        if (!reservedQueryNames[queryName]) {\r\n            propertyQuery[queryName] = query[queryName];\r\n        }\r\n    });\r\n\r\n    return propertyQuery;\r\n}\r\n\r\nfunction hasBeenAlreadyReceived(idempotenceId) {\r\n    var result = false;\r\n\r\n    if (idempotenceId) {\r\n        if (receivedMessageIds[idempotenceId]) {\r\n            result = true;\r\n        } else {\r\n            receivedMessageIds[idempotenceId] = true;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction triggerEvent(bpmnProcess, logger, eventName, data) {\r\n    var message = data || {};\r\n    logger.trace(\"Triggering event '\" + eventName + \"'\" + JSON.stringify(message));\r\n    bpmnProcess.triggerEvent(eventName, data);\r\n}\r\n\r\nfunction sendError(error, next) {\r\n    var restError;\r\n\r\n    if (error.bpmnParseErrors) {\r\n        restError = new restify.RestError({\r\n            restCode: \"BPMNParseError\",\r\n            body: error\r\n        });\r\n    } else {\r\n        restError = new restify.RestError({\r\n            restCode: \"BPMNExecutionError\",\r\n            message: error.toString()\r\n        });\r\n    }\r\n\r\n    return next(restError);\r\n}\r\n\r\n\r\nfunction onServerAfterEvent(logger, request, response, route, error) {\r\n    var requestInfo = {\r\n        method: request.method,\r\n        headers: request.headers,\r\n        body: request.body\r\n    };\r\n    var responseInfo = {\r\n        method: response.method,\r\n        headers: response.headers,\r\n        body: response.body\r\n    };\r\n\r\n    logger.debug(\"route: \" + JSON.stringify(route));\r\n    logger.debug(\"request: \" + JSON.stringify(requestInfo));\r\n    logger.debug(\"response: \" + JSON.stringify(responseInfo));\r\n\r\n    if (error) {\r\n        logger.debug(\"error: \" + JSON.stringify(error));\r\n\r\n    }\r\n }\r\n\r\n/**\r\n *\r\n * @param {ProcessManager} manager\r\n * @param {String} name\r\n * @param {Function} callback\r\n * @returns {*}\r\n */\r\nfunction getNameWithCase(manager, name, callback){\r\n\r\n    manager.getDefinitionNames(function(err, names){\r\n        if(err){\r\n            return callback(err);\r\n        }\r\n\r\n        var ret = null;\r\n\r\n        names.forEach(function(nameWithCase){\r\n            if(name.toLowerCase() === nameWithCase.toLowerCase()){\r\n                ret = nameWithCase;\r\n            }\r\n        });\r\n\r\n        callback(null, ret);\r\n    });\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-bpmn/node_modules/bpmn/lib/utils/bunyan2winston.js":"/**\r\n * Taken from https://github.com/trentm/node-bunyan-winston/blob/master/restify-winston.js\r\n */\r\n\"use strict\";\r\n\r\nvar bunyan = require('bunyan');\r\n\r\n\r\n// Pass a Bunyan logger to restify that shims to our winston Logger.\r\nexports.createLogger = function(log) {\r\n    return bunyan.createLogger({\r\n        name: 'bpmnRESTServer',\r\n        streams: [{\r\n            type: 'raw',\r\n            level: 'trace',\r\n            stream: new Bunyan2Winston(log)\r\n        }]\r\n    });\r\n};\r\n\r\n/**\r\n *\r\n * A Bunyan raw stream object (i.e. has a `.write(rec)` method that takes a\r\n * Bunyan log record) that shims logging to a given Winston logger.\r\n *\r\n * @param {winston.Logger} wlog is a Winston Logger to which to shim.\r\n */\r\nfunction Bunyan2Winston(wlog) {\r\n    this.wlog = wlog;\r\n}\r\nBunyan2Winston.prototype.write = function write(rec) {\r\n    // Map to the appropriate Winston log level (by default 'info', 'warn'\r\n    // or 'error') and call signature: `wlog.log(level, msg, metadata)`.\r\n    var wlevel;\r\n    if (rec.level <= bunyan.INFO) {\r\n        wlevel = 'info';\r\n    } else if (rec.level <= bunyan.WARN) {\r\n        wlevel = 'warn';\r\n    } else {\r\n        wlevel = 'error';\r\n    }\r\n\r\n    // Note: We are *modifying* the log record here. This could be a problem\r\n    // if our Bunyan logger had other streams. This one doesn't.\r\n    var msg = rec.msg;\r\n    delete rec.msg;\r\n\r\n    // Remove internal bunyan fields that won't mean anything outside of\r\n    // a bunyan context.\r\n    delete rec.v;\r\n    delete rec.level;\r\n    // TODO: more?\r\n\r\n    // Note: Winston doesn't handle *objects* in the 'metadata' field well\r\n    // (e.g. the Bunyan record 'time' field is a Date instance, 'req' and\r\n    // 'res' are typically objects). With 'json: true' on a Winston transport\r\n    // it is a bit better, but still messes up 'date'. What exactly to do\r\n    // here is perhaps user-preference.\r\n    rec.time = String(rec.time);\r\n    //Object.keys(rec).forEach(function (key) {\r\n    //    if (typeof(rec[key]) === \"object\") {\r\n    //        rec[key] = JSON.stringify(rec[key])\r\n    //    }\r\n    //});\r\n\r\n    this.wlog.log(wlevel, msg, rec);\r\n};\r\n\r\n\r\n\r\n"}